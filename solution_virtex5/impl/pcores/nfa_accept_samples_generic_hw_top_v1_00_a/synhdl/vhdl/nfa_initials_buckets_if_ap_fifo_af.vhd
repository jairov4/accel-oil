-- ==============================================================
-- File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
-- Version: 2014.1
-- Copyright (C) 2014 Xilinx Inc. All rights reserved.
-- 
-- ==============================================================


library ieee; 
use ieee.std_logic_1164.all; 
use ieee.std_logic_unsigned.all;

entity nfa_initials_buckets_if_ap_fifo_af_ram is 
    generic(
            mem_style  : string := "block"; 
            dwidth     : integer := 64; 
            awidth     : integer := 6; 
            mem_size    : integer := 64
    ); 
    port (
          clk       : in std_logic;
          din       : in std_logic_vector(dwidth-1 downto 0);
          w_addr    : in std_logic_vector(awidth-1 downto 0);
          we        : in std_logic; 
          r_addr    : in std_logic_vector(awidth-1 downto 0);
          dout      : out std_logic_vector(dwidth-1 downto 0)
    ); 
end entity; 

architecture rtl of nfa_initials_buckets_if_ap_fifo_af_ram is 

type mem_array is array (mem_size-1 downto 0) of std_logic_vector (dwidth-1 downto 0); 
signal mem : mem_array;

attribute ram_style : string;
attribute ram_style of mem : signal is mem_style;

begin 

p_memory_read: process (clk)  
begin 
    if (clk = '1' and clk'event) then
        if (we = '1') then 
            mem(CONV_INTEGER(w_addr)) <= din; 
        end if;
        dout <= mem(CONV_INTEGER(r_addr)); 
    end if;
end process;

end rtl;

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
entity nfa_initials_buckets_if_ap_fifo_af is 
    generic (
        MEM_STYLE  : string := "block"; 
        DATA_WIDTH : integer := 64;
        ADDR_WIDTH : integer := 6;
        DEPTH : integer := 64;
        ALMOST_FULL_MARGIN : integer := 2);
    port (
        clk : IN STD_LOGIC;
        reset : IN STD_LOGIC;
        if_empty_n : OUT STD_LOGIC;
        if_read : IN STD_LOGIC;
        if_dout : OUT STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0);
        if_full_n : OUT STD_LOGIC;
        if_write : IN STD_LOGIC;
        if_din : IN STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0));
end entity;

architecture rtl of nfa_initials_buckets_if_ap_fifo_af is

component nfa_initials_buckets_if_ap_fifo_af_ram is 
    generic(
            mem_style  : string := "block"; 
            dwidth     : integer := 64; 
            awidth     : integer := 6; 
            mem_size    : integer := 64
    ); 
    port (
          clk       : in std_logic;
          din       : in std_logic_vector(dwidth-1 downto 0);
          w_addr    : in std_logic_vector(awidth-1 downto 0);
          we        : in std_logic; 
          r_addr    : in std_logic_vector(awidth-1 downto 0);
          dout      : out std_logic_vector(dwidth-1 downto 0)
    ); 
end component; 

    signal mInPtr, mOutPtr : STD_LOGIC_VECTOR(ADDR_WIDTH - 1 downto 0);
    signal mInPtr_next, mOutPtr_next : STD_LOGIC_VECTOR(ADDR_WIDTH - 1 downto 0);
    signal ram_raddr, ram_waddr : STD_LOGIC_VECTOR(ADDR_WIDTH - 1 downto 0);
    signal ram_din, ram_dout : STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0);
    signal conflict_buff : STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0);
    signal conflict_buff_valid : STD_LOGIC;
    signal ram_we : STD_LOGIC;
    signal wordUsed : STD_LOGIC_VECTOR(ADDR_WIDTH downto 0);
    signal internal_empty_n, internal_full_n: STD_LOGIC;
begin
    if_empty_n <= internal_empty_n;
    if_full_n <= internal_full_n;
    ram_din <= if_din;

    process (wordUsed, conflict_buff_valid, conflict_buff, ram_dout)
    begin
        if ( wordUsed = 1 and conflict_buff_valid = '1' ) then
            if_dout <= conflict_buff;
        else
            if_dout <= ram_dout;
        end if;
    end process;

    process (mOutPtr)
    begin
        if ( mOutPtr < DEPTH -1 ) then
            mOutPtr_next <= mOutPtr + 1;
        else
            mOutPtr_next <= (others => '0');
        end if;
    end process;

    process (mInPtr)
    begin
        if ( mInPtr < DEPTH -1 ) then
            mInPtr_next <= mInPtr + 1;
        else
            mInPtr_next <= (others => '0');
        end if;
    end process;

    process (clk, reset)
    begin
        if reset = '1' then
            mInPtr <= (others => '0');
            mOutPtr <= (others => '0');
            wordUsed <= (others => '0');
            internal_empty_n <= '0';
            internal_full_n <= '1';
            conflict_buff <= (others => '0');
            conflict_buff_valid <= '0';
        else
            if clk'event and clk = '1' then
                if if_read = '1' and internal_empty_n = '1' then
                    mOutPtr <= mOutPtr_next;
                end if;
                if (if_write = '1') then
                    mInPtr <= mInPtr_next;
                end if;
                if (if_read = '1' and internal_empty_n = '1' and if_write = '0') then
                    wordUsed <= wordUsed -1;
                    if (wordUsed = 1) then 
                        internal_empty_n <= '0';
                    end if;
                    internal_full_n <= '1';
                elsif (if_read = '0' or internal_empty_n = '0') and 
                   (if_write = '1') then
                    wordUsed <= wordUsed +1;
                    internal_empty_n <= '1';
                    if (wordUsed + ALMOST_FULL_MARGIN = DEPTH -1) then 
                        internal_full_n <= '0';
                    end if;
                end if;
                conflict_buff <= if_din;
                conflict_buff_valid <= if_write and internal_full_n;
            end if;
        end if;
    end process;

    ram_waddr <= mInPtr;
    ram_raddr <= mOutPtr_next when if_read = '1' and internal_empty_n = '1' else mOutPtr;
    -- if a read occur on the following clock edge, prepare next read data in advance
    ram_we <= if_write; -- caller should check almost_full signal

    U_nfa_initials_buckets_if_ap_fifo_af_ram : nfa_initials_buckets_if_ap_fifo_af_ram
    generic map (
        mem_style => MEM_STYLE,
        dwidth => DATA_WIDTH,
        awidth => ADDR_WIDTH,
        mem_size => DEPTH)
    port map (
        clk => clk,
        din => ram_din,
        w_addr => ram_waddr,
        we => ram_we,
        r_addr => ram_raddr,
        dout => ram_dout);

end rtl;

