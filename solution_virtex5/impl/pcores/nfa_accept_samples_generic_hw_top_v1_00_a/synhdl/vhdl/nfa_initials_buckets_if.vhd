-- ==============================================================
-- File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
-- Version: 2014.1
-- Copyright (C) 2014 Xilinx Inc. All rights reserved.
-- 
-- ==============================================================


LIBRARY ieee;
USE ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

entity nfa_initials_buckets_if is
generic(
    MPMC_BASE_ADDRESS  : std_logic_vector     := X"00000000";
    USER_DATA_WIDTH    : integer := 32;
    USER_ADDR_SHIFT    : integer := 2  -- log2(byte_count_of_data_width)
);
port(

    --///////////////////////////////////////////////////////////////////////////////
    --// MPMC Port Interface - Bus is prefixed with NPI_
    NPI_clk                 : in std_logic;
    NPI_reset               : in std_logic;
    NPI_Addr                : out std_logic_vector(31 downto 0);
    NPI_AddrReq             : out std_logic;
    NPI_AddrAck             : in std_logic;
    NPI_RNW                 : out std_logic;
    NPI_Size                : out std_logic_vector(3 downto 0);
    NPI_WrFIFO_Data         : out std_logic_vector(63 downto 0);
    NPI_WrFIFO_BE           : out std_logic_vector(7 downto 0);
    NPI_WrFIFO_Push         : out std_logic;
    NPI_RdFIFO_Data         : in std_logic_vector(63 downto 0);
    NPI_RdFIFO_Pop          : out std_logic;
    NPI_RdFIFO_RdWdAddr     : in std_logic_vector(3 downto 0);
    NPI_WrFIFO_Empty        : in std_logic;
    NPI_WrFIFO_AlmostFull   : in std_logic;
    NPI_WrFIFO_Flush        : out std_logic;
    NPI_RdFIFO_Empty        : in std_logic;
    NPI_RdFIFO_Flush        : out std_logic;
    NPI_RdFIFO_Latency      : in std_logic_vector(1 downto 0);
    NPI_RdModWr             : out std_logic;
    NPI_InitDone            : in std_logic;

    -- signals from user logic
    ap_clk          : in std_logic;
    ap_reset        : in std_logic;
    USER_RdData     : out std_logic_vector(USER_DATA_WIDTH - 1 downto 0); -- Bus read data to user_logic
    USER_WrData     : in std_logic_vector(USER_DATA_WIDTH - 1 downto 0);  -- Bus write data
    USER_address    : in std_logic_vector(31 downto 0);        -- word offset from BASE_ADDRESS 
    USER_size       : in std_logic_vector(31 downto 0);        -- burst size of word
    USER_req_nRW    : in std_logic;                    -- req type 0: Read, 1: write
    USER_req_full_n : out std_logic;                -- req Fifo full
    USER_req_push   : in std_logic;                    -- req Fifo push (new request in)
    USER_rsp_empty_n: out std_logic;                -- return data FIFO empty
    USER_rsp_pop    : in std_logic                    -- return data FIFO pop
);
end entity;

architecture arch_nfa_initials_buckets_if OF nfa_initials_buckets_if IS

component nfa_initials_buckets_if_async_fifo is 
generic (
    DATA_WIDTH : integer := 32;
    ADDR_WIDTH : integer := 3;
    DEPTH : integer := 8);
port (
    clk_w : IN STD_LOGIC;
    clk_r : IN STD_LOGIC;
    reset : IN STD_LOGIC;
    if_din : IN STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0);
    if_full_n : OUT STD_LOGIC;
    if_write : IN STD_LOGIC;
    if_dout : OUT STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0);
    if_empty_n : OUT STD_LOGIC;
    if_read : IN STD_LOGIC);
end component;

component nfa_initials_buckets_if_ap_fifo is 
generic (
    DATA_WIDTH : integer := 32;
    ADDR_WIDTH : integer := 3;
    DEPTH : integer := 8);
port (
    clk : IN STD_LOGIC;
    reset : IN STD_LOGIC;
    if_din : IN STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0);
    if_full_n : OUT STD_LOGIC;
    if_write : IN STD_LOGIC;
    if_dout : OUT STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0);
    if_empty_n : OUT STD_LOGIC;
    if_read : IN STD_LOGIC);
end component;

component nfa_initials_buckets_if_ap_fifo_af is 
generic (
    DATA_WIDTH : integer := 64;
    ADDR_WIDTH : integer := 6;
    DEPTH : integer := 64;
    ALMOST_FULL_MARGIN : integer := 2);
port (
    clk : IN STD_LOGIC;
    reset : IN STD_LOGIC;
    if_din : IN STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0);
    if_full_n : OUT STD_LOGIC;
    if_write : IN STD_LOGIC;
    if_dout : OUT STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0);
    if_empty_n : OUT STD_LOGIC;
    if_read : IN STD_LOGIC);
end component;

constant C_PI_ADDR_WIDTH : integer := 32;
constant C_PI_DATA_WIDTH : integer := 64;
constant C_PI_BE_WIDTH : integer := 8;
constant C_PI_RDWDADDR_WIDTH: integer := 4;

constant RSW : integer := 7;  -- req size width
constant REQ_FIFO_DATA_WIDTH : integer := 1+32+RSW+USER_DATA_WIDTH; -- nRW+addr+size+wr_data
constant REQ_FIFO_ADDR_WIDTH : integer := 3;
constant REQ_FIFO_DEPTH : integer := 8;

type req_state_type is (RESET, FETCH_REQ, REQ, WD_SINGLE, WD_BURST1, WD_BURST2, WD_BURST_REQ);
signal req_cs, req_ns : req_state_type;

type rdata_state_type is (RESET, IDLE, RDATA);
signal rdata_cs, rdata_ns : rdata_state_type;

-- User interface
signal User_size_local : STD_LOGIC_VECTOR(RSW-1 downto 0);
signal User_address_local : STD_LOGIC_VECTOR(31 downto 0);

-- request FIFO
signal req_fifo_empty_n : STD_LOGIC;
signal req_fifo_pop : STD_LOGIC;
signal req_fifo_dout : STD_LOGIC_VECTOR(REQ_FIFO_DATA_WIDTH - 1 downto 0);
signal req_fifo_full_n : STD_LOGIC;
signal req_fifo_push : STD_LOGIC;
signal req_fifo_din : STD_LOGIC_VECTOR(REQ_FIFO_DATA_WIDTH - 1 downto 0);

signal req_fifo_dout_req_nRW : STD_LOGIC;
signal req_fifo_dout_req_address : STD_LOGIC_VECTOR(31 downto 0);
signal req_fifo_dout_req_size : STD_LOGIC_VECTOR(RSW-1 downto 0);
signal req_fifo_dout_wr_data : STD_LOGIC_VECTOR(USER_DATA_WIDTH-1 downto 0);

signal req_reg_en : STD_LOGIC;
signal nRW_reg : STD_LOGIC;
signal address_reg : STD_LOGIC_VECTOR(31 downto 0);
signal size_reg : STD_LOGIC_VECTOR(RSW-1 downto 0);

-- internal request information
signal req_nRW : STD_LOGIC;
signal req_address : STD_LOGIC_VECTOR(31 downto 0);
signal req_size : STD_LOGIC_VECTOR(RSW-1 downto 0);
signal req_BE : STD_LOGIC_VECTOR(C_PI_BE_WIDTH-1 downto 0);
signal req_WrData_low : STD_LOGIC_VECTOR(USER_DATA_WIDTH-1 downto 0);
signal req_WrData_wdAddr : STD_LOGIC;
signal req_WrData_reg_en : STD_LOGIC;
signal req_WrData_push : STD_LOGIC;
signal req_WrData_BE : STD_LOGIC_VECTOR(C_PI_BE_WIDTH-1 downto 0);
signal req_valid : STD_LOGIC;

-- burst write 
signal burst_write_reg_en : STD_LOGIC;
signal burst_write_count : STD_LOGIC_VECTOR(5 downto 0); -- max 32 * 64 bits

-- burst read 
signal burst_read_reg_en : STD_LOGIC;
signal burst_read_count : STD_LOGIC_VECTOR(RSW-1 downto 0);
signal burst_read_wdAddr : STD_LOGIC;

-- rsp FIFO 
constant RSP_FIFO_DATA_WIDTH : integer := RSW + 1; -- req_size + addr(2)
constant RSP_FIFO_ADDR_WIDTH : integer := 2;
constant RSP_FIFO_DEPTH : integer := 4; -- MPMC limitation 

signal rsp_fifo_empty_n : STD_LOGIC;
signal rsp_fifo_pop : STD_LOGIC;
signal rsp_fifo_dout : STD_LOGIC_VECTOR(RSP_FIFO_DATA_WIDTH-1 downto 0);
signal rsp_fifo_full_n : STD_LOGIC;
signal rsp_fifo_push : STD_LOGIC;
signal rsp_fifo_din : STD_LOGIC_VECTOR(RSP_FIFO_DATA_WIDTH-1 downto 0);

-- internal rdata pop logic
signal rdata_pop, rdata_pop_reg1, rdata_pop_reg2: STD_LOGIC;

-- rd FIFO: input: MPMC data out, output: user async fifo
signal rd_fifo_empty_n : STD_LOGIC;
signal rd_fifo_pop : STD_LOGIC;
signal rd_fifo_dout : STD_LOGIC_VECTOR(C_PI_DATA_WIDTH -1 downto 0);
signal rd_fifo_full_n : STD_LOGIC;
signal rd_fifo_push : STD_LOGIC;
signal rd_fifo_din : STD_LOGIC_VECTOR(C_PI_DATA_WIDTH -1 downto 0);

signal rd_fifo_dout_endian : STD_LOGIC_VECTOR(C_PI_DATA_WIDTH -1 downto 0);

-- rd user FIFO: async fifo to user
signal rd_user_fifo_empty_n : STD_LOGIC;
signal rd_user_fifo_pop : STD_LOGIC;
signal rd_user_fifo_dout : STD_LOGIC_VECTOR(USER_DATA_WIDTH -1 downto 0);
signal rd_user_fifo_full_n : STD_LOGIC;
signal rd_user_fifo_push : STD_LOGIC;
signal rd_user_fifo_din : STD_LOGIC_VECTOR(USER_DATA_WIDTH -1 downto 0);

begin

  -- NPI interface
  NPI_WrFIFO_Flush <= '0';
  NPI_RdFIFO_Flush <= '0';
  NPI_RdModWr <= '0';

  NPI_AddrReq <= req_valid;
  NPI_Addr <= address_reg;
  NPI_RNW <= not nRW_reg;
  NPI_WrFIFO_Push <= req_WrData_push;
  NPI_WrFIFO_BE <= req_WrData_BE;
  NPI_RdFIFO_Pop <= rdata_pop;

  process (req_WrData_wdAddr, req_WrData_low, req_fifo_dout_wr_data)
  begin
      NPI_WrFIFO_Data <= (others => '0');
      if (req_WrData_wdAddr = '0') then
          NPI_WrFIFO_Data(C_PI_DATA_WIDTH-1 downto USER_DATA_WIDTH) <= req_fifo_dout_wr_data;
          NPI_WrFIFO_Data(USER_DATA_WIDTH-1 downto 0) <= req_WrData_low;
      else
          NPI_WrFIFO_Data(C_PI_DATA_WIDTH-1 downto USER_DATA_WIDTH) <= req_WrData_low;
          NPI_WrFIFO_Data(USER_DATA_WIDTH-1 downto 0) <= req_fifo_dout_wr_data;
      end if;
  end process;

  process (size_reg)
  begin
      NPI_Size <= (others => '0');
      if (size_reg = "0000100") then --4w
          NPI_Size <= "0001";
      elsif (size_reg = "0001000") then --8w
          NPI_Size <= "0010";
      elsif (size_reg = "0010000") then --16w
          NPI_Size <= "0011";
      elsif (size_reg = "0100000") then --32w
          NPI_Size <= "0100";
      elsif (size_reg = "1000000") then --64w
          NPI_Size <= "0101";
      end if;
  end process;

  -- User interface
  USER_req_full_n <= req_fifo_full_n;

  USER_rsp_empty_n <= rd_user_fifo_empty_n;
  USER_RdData <= rd_user_fifo_dout;
  rd_user_fifo_pop <= USER_rsp_pop;

  USER_size_local <= User_size(RSW-1 downto 0) when 
      User_size(RSW-1 downto 0) /= CONV_STD_LOGIC_VECTOR(0,RSW) else CONV_STD_LOGIC_VECTOR(1,RSW);
  USER_address_local(31 downto USER_ADDR_SHIFT) <= USER_address(31-USER_ADDR_SHIFT downto 0);
  USER_address_local(USER_ADDR_SHIFT-1 downto 0) <= (others => '0');

  -- reqest fifo logics
  req_fifo_din(REQ_FIFO_DATA_WIDTH-1) <= USER_req_nRW;
  req_fifo_din(REQ_FIFO_DATA_WIDTH-1-1 downto REQ_FIFO_DATA_WIDTH -1-32) <= USER_address_local+MPMC_BASE_ADDRESS;
  req_fifo_din(REQ_FIFO_DATA_WIDTH-1-32-1 downto REQ_FIFO_DATA_WIDTH-1-32-RSW) <= USER_size_local(RSW-1 downto 0);
  req_fifo_din(USER_DATA_WIDTH -1 downto 0) <= USER_WrData;
  req_fifo_push <= USER_req_push;

  U_nfa_initials_buckets_if_req_fifo: component nfa_initials_buckets_if_async_fifo 
  generic map(
    DATA_WIDTH => REQ_FIFO_DATA_WIDTH,
    ADDR_WIDTH => REQ_FIFO_ADDR_WIDTH,
    DEPTH => REQ_FIFO_DEPTH)
  port map(
    clk_w => ap_clk,
    clk_r => NPI_clk,
    reset => NPI_reset,
    if_empty_n => req_fifo_empty_n,
    if_read => req_fifo_pop,
    if_dout => req_fifo_dout,
    if_full_n => req_fifo_full_n,
    if_write => req_fifo_push,
    if_din => req_fifo_din
  );

  req_fifo_dout_req_nRW <= req_fifo_dout(REQ_FIFO_DATA_WIDTH -1);
  req_fifo_dout_req_address <= req_fifo_dout(REQ_FIFO_DATA_WIDTH-1-1 downto REQ_FIFO_DATA_WIDTH -1-32);
  req_fifo_dout_req_size <= req_fifo_dout(REQ_FIFO_DATA_WIDTH-1-32-1 downto REQ_FIFO_DATA_WIDTH -1-32-RSW);

  process(req_fifo_dout)
  variable i,j: integer;
  begin
    -- change byte endian to big endian 
    for i in 0 to USER_DATA_WIDTH/8-1 loop
        j := USER_DATA_WIDTH/8 -1 -i;
        req_fifo_dout_wr_data(i*8+7 downto i*8) <= req_fifo_dout(j*8+7 downto j*8);
    end loop;
  end process;

  p_req_fifo_out_reg: process (NPI_clk, NPI_reset)
  variable i,j: integer;
  begin
    if (NPI_reset = '1') then
        nRW_reg <= '0';
        address_reg <= (others => '0');
        size_reg <= (others => '0');
    elsif (NPI_clk'event and NPI_clk = '1') then
        if (req_reg_en = '1') then
            nRW_reg <= req_fifo_dout_req_nRW;
            address_reg <= req_fifo_dout_req_address;
            size_reg <= req_fifo_dout_req_size;
        end if;
    end if;
  end process;

  -- write and burst write will be controlled by state machine due to MPMC limitation
  -- read and burst read will have seperate return data phase logic for a pipelined access
  p_state_trans: process (NPI_clk, NPI_reset)
  begin
    if (NPI_reset = '1') then
        req_cs <= RESET;
    elsif (NPI_clk'event and NPI_clk = '1') then
        req_cs <= req_ns;
    end if;
  end process;

  -- CAUTION: NPI_AddrAck is a combinational output of NPI_AddrReq
  -- do not make NPI_AddrReq(req_valid) depends on NPI_AddrAck
  p_state_output: process (req_cs, NPI_InitDone, req_fifo_empty_n, req_fifo_dout_req_nRW, 
          NPI_AddrAck, rsp_fifo_full_n, nRW_reg, size_reg, burst_write_count,
          req_WrData_wdAddr, req_fifo_dout_req_size, NPI_WrFIFO_AlmostFull)
  begin
      req_ns <= FETCH_REQ;

      req_reg_en <= '0';
      req_fifo_pop <= '0';
      rsp_fifo_push <= '0';
      req_WrData_reg_en <= '0';
      burst_write_reg_en <= '0';

      req_valid <= '0';
      req_WrData_push <= '0';
      req_WrData_BE <= "11111111";

      case req_cs is
      when RESET => 
          req_ns <= RESET;
          if (NPI_InitDone = '1') then
              req_ns <= FETCH_REQ;
          end if;
      when FETCH_REQ =>
          req_ns <= FETCH_REQ;
          if (req_fifo_empty_n = '1') then
              if (req_fifo_dout_req_nRW = '1') then
                  req_reg_en <= '1';
                  req_ns <= REQ;
              elsif (rsp_fifo_full_n = '1') then
                  req_reg_en <= '1';
                  req_fifo_pop <= '1';
                  rsp_fifo_push <= '1';
                  req_ns <= REQ;
              end if;
          end if;
      when REQ =>
          req_ns <= REQ;
          if (nRW_reg = '0') then
              req_valid <= '1';
              if (NPI_AddrAck = '1') then
                  req_ns <= FETCH_REQ;
              end if;
          elsif (nRW_reg = '1' and size_reg = CONV_STD_LOGIC_VECTOR(1,RSW)) then
              req_valid <= '1';
              if (NPI_AddrAck = '1') then
                  req_WrData_reg_en <= '1';
                  req_ns <= WD_SINGLE;
              end if;
          elsif (nRW_reg = '1' and size_reg /= CONV_STD_LOGIC_VECTOR(1,RSW)) then
              burst_write_reg_en <= '1';
              req_ns <= WD_BURST1;
          end if;
      when WD_SINGLE =>
          req_ns <= WD_SINGLE;
          if (NPI_WrFIFO_AlmostFull = '0') then
              req_WrData_push <= '1';
              req_fifo_pop <= '1';
              req_ns <= FETCH_REQ;
          end if;
          if (req_WrData_wdAddr = '0') then
              req_WrData_BE <= "00001111";
          else
              req_WrData_BE <= "11110000";
          end if;
      when WD_BURST1 => 
          req_ns <= WD_BURST1;
          if (req_fifo_empty_n = '1') then
              req_fifo_pop <= '1';
              req_WrData_reg_en <= '1';
              req_ns <= WD_BURST2;
          end if;
      when WD_BURST2 => 
          req_ns <= WD_BURST2;
          if (req_fifo_empty_n = '1' and NPI_WrFIFO_AlmostFull = '0') then
              req_fifo_pop <= '1';
              req_WrData_push <= '1';
              if (burst_write_count /= "000001") then -- not last word
                  req_ns <= WD_BURST1;
              else
                  req_ns <= WD_BURST_REQ;
              end if;
          end if;
      when WD_BURST_REQ => 
          req_ns <= WD_BURST_REQ;
          req_valid <= '1';
          if (NPI_AddrAck = '1') then
              req_ns <= FETCH_REQ;
          end if;
      when others => null;
      end case;
  end process;

  process (NPI_clk, NPI_reset)
  begin
      if (NPI_reset = '1') then
          req_WrData_low <= (others =>'0');
          req_WrData_wdAddr <= '0';
          burst_write_count <= (others =>'0');
      elsif (NPI_clk'event and NPI_clk = '1') then
          if (req_WrData_reg_en = '1') then
              req_WrData_low <= req_fifo_dout_wr_data;
              req_WrData_wdAddr <= req_fifo_dout_req_address(2);
          end if;
          if (burst_write_reg_en = '1') then
              burst_write_count <= req_fifo_dout_req_size(RSW-1 downto RSW-6);
          elsif (req_WrData_push = '1') then
              burst_write_count <= burst_write_count-1;
          end if;
      end if;
  end process;

  -- below is the response (read data) part
  U_nfa_initials_buckets_if_rsp_fifo: component nfa_initials_buckets_if_ap_fifo
  generic map(
    DATA_WIDTH => RSP_FIFO_DATA_WIDTH,
    ADDR_WIDTH => RSP_FIFO_ADDR_WIDTH,
    DEPTH => RSP_FIFO_DEPTH)
  port map(
    clk        => NPI_clk,
    reset      => NPI_reset,
    if_empty_n => rsp_fifo_empty_n,
    if_read    => rsp_fifo_pop,
    if_dout    => rsp_fifo_dout,
    if_full_n  => rsp_fifo_full_n,
    if_write   => rsp_fifo_push,
    if_din     => rsp_fifo_din
  );
  rsp_fifo_din(RSP_FIFO_DATA_WIDTH-1 downto 1) <= req_fifo_dout_req_size;
  rsp_fifo_din(0) <= req_fifo_dout_req_address(2);

  rdata_pop <= (not NPI_RdFIFO_Empty) and rd_fifo_full_n;

  process (NPI_clk, NPI_reset)
  begin
      if (NPI_reset = '1') then
          rdata_pop_reg1 <= '0';
          rdata_pop_reg2 <= '0';
      elsif (NPI_clk'event and NPI_clk = '1') then
          rdata_pop_reg1 <= rdata_pop;
          rdata_pop_reg2 <= rdata_pop_reg1;
      end if;
  end process;

  process (NPI_RdFIFO_Latency, rdata_pop, rdata_pop_reg1, rdata_pop_reg2)
  begin
    if (NPI_RdFIFO_Latency = "00") then
        rd_fifo_push <= rdata_pop;
    elsif (NPI_RdFIFO_Latency = "01") then
        rd_fifo_push <= rdata_pop_reg1;
    else
        rd_fifo_push <= rdata_pop_reg2;
    end if;
  end process;

  rd_fifo_din <= NPI_RdFIFO_Data;

  -- 1. this fifo provide two 64w burst storage
  -- 2. with almost full signal for MPMC has potential 2 latency from pop to data
  -- 3. can't replace this fifo with asyn fifo which doesn't support almost_full
  U_nfa_initials_buckets_if_rd_fifo: component nfa_initials_buckets_if_ap_fifo_af
  generic map(
    DATA_WIDTH => C_PI_DATA_WIDTH,
    ADDR_WIDTH => 6,
    DEPTH => 64,
    ALMOST_FULL_MARGIN => 2)
  port map(
    clk        => NPI_clk,
    reset      => NPI_reset,
    if_empty_n => rd_fifo_empty_n,
    if_read    => rd_fifo_pop,
    if_dout    => rd_fifo_dout,
    if_full_n  => rd_fifo_full_n, -- this is almost_full signal
    if_write   => rd_fifo_push,
    if_din     => rd_fifo_din
  );

  process(rd_fifo_dout)
  variable i,j : integer;
  begin
    -- change byte endian to big endian 
    for i in 0 to C_PI_BE_WIDTH-1 loop
        j := C_PI_BE_WIDTH-1 -i;
        rd_fifo_dout_endian(i*8+7 downto i*8) <= rd_fifo_dout(j*8+7 downto j*8);
    end loop;
  end process;

  p_rdata_state_trans: process (NPI_clk, NPI_reset)
  begin
    if (NPI_reset = '1') then
        rdata_cs <= RESET;
    elsif (NPI_clk'event and NPI_clk = '1') then
        rdata_cs <= rdata_ns;
    end if;
  end process;

  p_rdata_ns_gen: process (rdata_cs, NPI_InitDone, rsp_fifo_empty_n, burst_read_count)
  begin
      rdata_ns <= RESET;

      case rdata_cs is
      when RESET => 
          if (NPI_InitDone = '1') then
              rdata_ns <= IDLE;
          end if;
      when IDLE =>
          rdata_ns <= IDLE;
          if (rsp_fifo_empty_n = '1') then
              rdata_ns <= RDATA;
          end if;
      when RDATA =>
          rdata_ns <= RDATA;
          if (burst_read_count = CONV_STD_LOGIC_VECTOR(0,RSW)) then
              rdata_ns <= IDLE;
          end if;
      when others => null;
      end case;
  end process;

  p_rdata_state_output: process (rdata_cs, rsp_fifo_empty_n, burst_read_count, 
               rd_fifo_empty_n, rd_user_fifo_full_n)
  begin
      burst_read_reg_en <= '0';
      rd_fifo_pop <= '0';
      rd_user_fifo_push <= '0';
      rsp_fifo_pop <= '0';

      case rdata_cs is
      when RESET => null;
      when IDLE => 
          if (rsp_fifo_empty_n = '1') then
              burst_read_reg_en <= '1';
          end if;
      when RDATA =>
          if (burst_read_count /= CONV_STD_LOGIC_VECTOR(0,RSW) and rd_fifo_empty_n = '1' and
              rd_user_fifo_full_n = '1') then
              if (burst_read_count(0) = '1') then
                  rd_fifo_pop <= '1';
              end if;
              rd_user_fifo_push <= '1';
          end if;
          if (burst_read_count = CONV_STD_LOGIC_VECTOR(0, RSW) ) then
              rsp_fifo_pop <= '1';
          end if;
      when others => null;
      end case;
  end process;

  process (NPI_clk, NPI_reset)
  begin
      if (NPI_reset = '1') then
          burst_read_count <= (others =>'0');
      elsif (NPI_clk'event and NPI_clk = '1') then
          if (burst_read_reg_en = '1') then
              burst_read_count <= rsp_fifo_dout(RSP_FIFO_DATA_WIDTH-1 downto RSP_FIFO_DATA_WIDTH-RSW);
              burst_read_wdAddr <= rsp_fifo_dout(0);
          elsif (rd_user_fifo_push = '1') then
              burst_read_count <= burst_read_count -1;
              burst_read_wdAddr <= not burst_read_wdAddr;
          end if;
      end if;
  end process;

  rd_user_fifo_din <= rd_fifo_dout_endian(USER_DATA_WIDTH-1 downto 0) when burst_read_wdAddr = '1' else
                      rd_fifo_dout_endian(C_PI_DATA_WIDTH-1 downto USER_DATA_WIDTH);

  U_nfa_initials_buckets_if_rd_user_fifo: component nfa_initials_buckets_if_async_fifo
  generic map(
    DATA_WIDTH => USER_DATA_WIDTH,
    ADDR_WIDTH => 3,
    DEPTH => 8)
  port map(
    clk_w      => NPI_clk,
    clk_r      => ap_clk,
    reset      => NPI_reset,
    if_empty_n => rd_user_fifo_empty_n,
    if_read    => rd_user_fifo_pop,
    if_dout    => rd_user_fifo_dout,
    if_full_n  => rd_user_fifo_full_n,
    if_write   => rd_user_fifo_push,
    if_din     => rd_user_fifo_din
  );

end arch_nfa_initials_buckets_if; 

