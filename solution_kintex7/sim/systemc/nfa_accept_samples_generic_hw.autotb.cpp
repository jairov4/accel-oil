// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2013.4
// Copyright (C) 2013 Xilinx Inc. All rights reserved.
// 
// ==============================================================

#include "nfa_accept_samples_generic_hw.h"
#include "AESL_autobus_nfa_initials_buckets.h"
#include "AESL_autobus_nfa_finals_buckets.h"
#include "AESL_autobus_nfa_forward_buckets.h"
#include "AESL_autobus_sample_buffer.h"
#include "AESL_autobus_indices_begin.h"
#include "AESL_autobus_indices_samples.h"
#include "AESL_autobus_indices_stride.h"
#include "autosim_file.h"

using namespace std;
using namespace sc_core;
using namespace sc_dt;

#define AUTOTB_DUT      nfa_accept_samples_generic_hw
#define AUTOTB_DUT_INST AESL_inst_nfa_accept_samples_generic_hw
#define AUTOTB_TOP      apatb_nfa_accept_samples_generic_hw_top
#define AUTOTB_LAT_RESULT_FILE "nfa_accept_samples_generic_hw.result.lat.rb"
#define AUTOTB_PER_RESULT_TRANS_FILE "nfa_accept_samples_generic_hw.performance.result.transaction.xml"
#define AUTOTB_TOP_INST AESL_inst_apatb_nfa_accept_samples_generic_hw_top
#define AUTOTB_TRANSACTION_NUM  4
#define AUTOTB_TVIN     "nfa_accept_samples_generic_hw.autotvin.dat"
#define AUTOTB_TVOUT    "nfa_accept_samples_generic_hw.autotvout.dat"
#define AUTOTB_HDL_TVIN "nfa_accept_samples_generic_hw.hdltvin.dat"
#define AUTOTB_HDL_TVOUT "nfa_accept_samples_generic_hw.hdltvout.dat"
#define LENGTH_nfa_initials_buckets 2
#define LENGTH_nfa_finals_buckets 2
#define LENGTH_nfa_forward_buckets 10
#define LENGTH_nfa_symbols 1
#define LENGTH_sample_buffer 10
#define LENGTH_sample_buffer_length 1
#define LENGTH_sample_length 1
#define LENGTH_indices_begin 10
#define LENGTH_indices_samples 10
#define LENGTH_indices_stride 10
#define LENGTH_begin_index 1
#define LENGTH_begin_sample 1
#define LENGTH_end_index 1
#define LENGTH_end_sample 1
#define LENGTH_stop_on_first 1
#define LENGTH_accept 1
#define LENGTH_ap_return 1

#define REF_TCL_FILE "../tv/cdatafile/ref.tcl"
#define AUTOTB_TVIN_nfa_initials_buckets  "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_nfa_initials_buckets.dat"
#define AUTOTB_TVIN_nfa_finals_buckets  "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_nfa_finals_buckets.dat"
#define AUTOTB_TVIN_nfa_forward_buckets  "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_nfa_forward_buckets.dat"
#define AUTOTB_TVIN_nfa_symbols  "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_nfa_symbols.dat"
#define AUTOTB_TVIN_sample_buffer  "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_sample_buffer.dat"
#define AUTOTB_TVIN_sample_buffer_length  "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_sample_buffer_length.dat"
#define AUTOTB_TVIN_sample_length  "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_sample_length.dat"
#define AUTOTB_TVIN_indices_begin  "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_indices_begin.dat"
#define AUTOTB_TVIN_indices_samples  "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_indices_samples.dat"
#define AUTOTB_TVIN_indices_stride  "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_indices_stride.dat"
#define AUTOTB_TVIN_begin_index  "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_begin_index.dat"
#define AUTOTB_TVIN_begin_sample  "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_begin_sample.dat"
#define AUTOTB_TVIN_end_index  "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_end_index.dat"
#define AUTOTB_TVIN_end_sample  "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_end_sample.dat"
#define AUTOTB_TVIN_stop_on_first  "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_stop_on_first.dat"
#define AUTOTB_TVIN_accept  "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_accept.dat"
#define AUTOTB_TVIN_nfa_initials_buckets_out_wrapc  "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_nfa_initials_buckets.dat"
#define AUTOTB_TVIN_nfa_finals_buckets_out_wrapc  "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_nfa_finals_buckets.dat"
#define AUTOTB_TVIN_nfa_forward_buckets_out_wrapc  "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_nfa_forward_buckets.dat"
#define AUTOTB_TVIN_nfa_symbols_out_wrapc  "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_nfa_symbols.dat"
#define AUTOTB_TVIN_sample_buffer_out_wrapc  "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_sample_buffer.dat"
#define AUTOTB_TVIN_sample_buffer_length_out_wrapc  "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_sample_buffer_length.dat"
#define AUTOTB_TVIN_sample_length_out_wrapc  "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_sample_length.dat"
#define AUTOTB_TVIN_indices_begin_out_wrapc  "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_indices_begin.dat"
#define AUTOTB_TVIN_indices_samples_out_wrapc  "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_indices_samples.dat"
#define AUTOTB_TVIN_indices_stride_out_wrapc  "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_indices_stride.dat"
#define AUTOTB_TVIN_begin_index_out_wrapc  "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_begin_index.dat"
#define AUTOTB_TVIN_begin_sample_out_wrapc  "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_begin_sample.dat"
#define AUTOTB_TVIN_end_index_out_wrapc  "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_end_index.dat"
#define AUTOTB_TVIN_end_sample_out_wrapc  "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_end_sample.dat"
#define AUTOTB_TVIN_stop_on_first_out_wrapc  "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_stop_on_first.dat"
#define AUTOTB_TVIN_accept_out_wrapc  "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_accept.dat"
#define AUTOTB_TVOUT_ap_return  "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvout_ap_return.dat"
#define AUTOTB_TVOUT_ap_return_out_wrapc  "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvout_ap_return.dat"


SC_MODULE(AUTOTB_TOP)
{
#if defined(AESL_APATB_ALDEC)
    sc_in< sc_logic > AESL_clock;
    sc_signal< bool > AESL_clock_bool;
#endif
#if !defined(AESL_APATB_ALDEC)
    sc_in_clk AESL_clock;
#endif
    sc_signal< sc_logic > AESL_reset;
    sc_signal< sc_logic > AESL_start;
    sc_signal< sc_logic > AESL_ce;
    sc_signal< sc_logic > AESL_idle;
    sc_signal< sc_logic > AESL_done;
    sc_signal< sc_logic > AESL_ready;
    sc_signal< sc_logic > AESL_continue;
    sc_signal< sc_logic > AESL_transaction_ready;
    sc_signal< sc_logic > AESL_interface_done;
    sc_signal< sc_logic > AESL_transaction_ready_nfa_initials_buckets;
    sc_signal< sc_logic > AESL_transaction_done_nfa_initials_buckets;
    sc_signal< sc_logic > AESL_transaction_ready_nfa_finals_buckets;
    sc_signal< sc_logic > AESL_transaction_done_nfa_finals_buckets;
    sc_signal< sc_logic > AESL_transaction_ready_nfa_forward_buckets;
    sc_signal< sc_logic > AESL_transaction_done_nfa_forward_buckets;
    sc_signal< sc_logic > AESL_transaction_ready_nfa_backward_buckets;
    sc_signal< sc_logic > AESL_transaction_done_nfa_backward_buckets;
    sc_signal< sc_logic > AESL_transaction_ready_nfa_symbols;
    sc_signal< sc_logic > AESL_transaction_done_nfa_symbols;
    sc_signal< sc_logic > AESL_transaction_ready_sample_buffer;
    sc_signal< sc_logic > AESL_transaction_done_sample_buffer;
    sc_signal< sc_logic > AESL_transaction_ready_sample_buffer_length;
    sc_signal< sc_logic > AESL_transaction_done_sample_buffer_length;
    sc_signal< sc_logic > AESL_transaction_ready_sample_length;
    sc_signal< sc_logic > AESL_transaction_done_sample_length;
    sc_signal< sc_logic > AESL_transaction_ready_indices_begin;
    sc_signal< sc_logic > AESL_transaction_done_indices_begin;
    sc_signal< sc_logic > AESL_transaction_ready_indices_samples;
    sc_signal< sc_logic > AESL_transaction_done_indices_samples;
    sc_signal< sc_logic > AESL_transaction_ready_indices_stride;
    sc_signal< sc_logic > AESL_transaction_done_indices_stride;
    sc_signal< sc_logic > AESL_transaction_ready_i_size;
    sc_signal< sc_logic > AESL_transaction_done_i_size;
    sc_signal< sc_logic > AESL_transaction_ready_begin_index;
    sc_signal< sc_logic > AESL_transaction_done_begin_index;
    sc_signal< sc_logic > AESL_transaction_ready_begin_sample;
    sc_signal< sc_logic > AESL_transaction_done_begin_sample;
    sc_signal< sc_logic > AESL_transaction_ready_end_index;
    sc_signal< sc_logic > AESL_transaction_done_end_index;
    sc_signal< sc_logic > AESL_transaction_ready_end_sample;
    sc_signal< sc_logic > AESL_transaction_done_end_sample;
    sc_signal< sc_logic > AESL_transaction_ready_stop_on_first;
    sc_signal< sc_logic > AESL_transaction_done_stop_on_first;
    sc_signal< sc_logic > AESL_transaction_ready_accept;
    sc_signal< sc_logic > AESL_transaction_done_accept;
    sc_signal< sc_logic > AESL_ready_delay;
    sc_signal< sc_logic > AESL_done_delay;
    sc_signal< sc_logic > AESL_initial_ready;

    sc_signal< sc_logic > nfa_initials_buckets_req_din;
    sc_signal< sc_logic > nfa_initials_buckets_req_full_n;
    sc_signal< sc_logic > nfa_initials_buckets_req_write;
    sc_signal< sc_logic > nfa_initials_buckets_rsp_empty_n;
    sc_signal< sc_logic > nfa_initials_buckets_rsp_read;
    sc_signal< sc_lv<32> > nfa_initials_buckets_address;
    sc_signal< sc_lv<32> > nfa_initials_buckets_datain;
    sc_signal< sc_lv<32> > nfa_initials_buckets_dataout;
    sc_signal< sc_lv<32> > nfa_initials_buckets_size;
    sc_signal< sc_logic > nfa_finals_buckets_req_din;
    sc_signal< sc_logic > nfa_finals_buckets_req_full_n;
    sc_signal< sc_logic > nfa_finals_buckets_req_write;
    sc_signal< sc_logic > nfa_finals_buckets_rsp_empty_n;
    sc_signal< sc_logic > nfa_finals_buckets_rsp_read;
    sc_signal< sc_lv<32> > nfa_finals_buckets_address;
    sc_signal< sc_lv<32> > nfa_finals_buckets_datain;
    sc_signal< sc_lv<32> > nfa_finals_buckets_dataout;
    sc_signal< sc_lv<32> > nfa_finals_buckets_size;
    sc_signal< sc_logic > nfa_forward_buckets_req_din;
    sc_signal< sc_logic > nfa_forward_buckets_req_full_n;
    sc_signal< sc_logic > nfa_forward_buckets_req_write;
    sc_signal< sc_logic > nfa_forward_buckets_rsp_empty_n;
    sc_signal< sc_logic > nfa_forward_buckets_rsp_read;
    sc_signal< sc_lv<32> > nfa_forward_buckets_address;
    sc_signal< sc_lv<32> > nfa_forward_buckets_datain;
    sc_signal< sc_lv<32> > nfa_forward_buckets_dataout;
    sc_signal< sc_lv<32> > nfa_forward_buckets_size;
    sc_signal< sc_lv<8> > nfa_symbols;
    sc_signal< sc_logic > sample_buffer_req_din;
    sc_signal< sc_logic > sample_buffer_req_full_n;
    sc_signal< sc_logic > sample_buffer_req_write;
    sc_signal< sc_logic > sample_buffer_rsp_empty_n;
    sc_signal< sc_logic > sample_buffer_rsp_read;
    sc_signal< sc_lv<32> > sample_buffer_address;
    sc_signal< sc_lv<8> > sample_buffer_datain;
    sc_signal< sc_lv<8> > sample_buffer_dataout;
    sc_signal< sc_lv<32> > sample_buffer_size;
    sc_signal< sc_lv<32> > sample_buffer_length;
    sc_signal< sc_lv<16> > sample_length;
    sc_signal< sc_logic > indices_begin_req_din;
    sc_signal< sc_logic > indices_begin_req_full_n;
    sc_signal< sc_logic > indices_begin_req_write;
    sc_signal< sc_logic > indices_begin_rsp_empty_n;
    sc_signal< sc_logic > indices_begin_rsp_read;
    sc_signal< sc_lv<32> > indices_begin_address;
    sc_signal< sc_lv<32> > indices_begin_datain;
    sc_signal< sc_lv<32> > indices_begin_dataout;
    sc_signal< sc_lv<32> > indices_begin_size;
    sc_signal< sc_logic > indices_samples_req_din;
    sc_signal< sc_logic > indices_samples_req_full_n;
    sc_signal< sc_logic > indices_samples_req_write;
    sc_signal< sc_logic > indices_samples_rsp_empty_n;
    sc_signal< sc_logic > indices_samples_rsp_read;
    sc_signal< sc_lv<32> > indices_samples_address;
    sc_signal< sc_lv<16> > indices_samples_datain;
    sc_signal< sc_lv<16> > indices_samples_dataout;
    sc_signal< sc_lv<32> > indices_samples_size;
    sc_signal< sc_logic > indices_stride_req_din;
    sc_signal< sc_logic > indices_stride_req_full_n;
    sc_signal< sc_logic > indices_stride_req_write;
    sc_signal< sc_logic > indices_stride_rsp_empty_n;
    sc_signal< sc_logic > indices_stride_rsp_read;
    sc_signal< sc_lv<32> > indices_stride_address;
    sc_signal< sc_lv<8> > indices_stride_datain;
    sc_signal< sc_lv<8> > indices_stride_dataout;
    sc_signal< sc_lv<32> > indices_stride_size;
    sc_signal< sc_lv<16> > i_size;
    sc_signal< sc_lv<16> > begin_index;
    sc_signal< sc_lv<16> > begin_sample;
    sc_signal< sc_lv<16> > end_index;
    sc_signal< sc_lv<16> > end_sample;
    sc_signal< sc_lv<1> > stop_on_first;
    sc_signal< sc_lv<1> > accept;
    sc_signal< sc_lv<32> > ap_return;
    sc_signal< sc_lv<32> > AESL_BUFF_ap_return;

    AUTOTB_DUT * AUTOTB_DUT_INST;


    AESL_autobus_nfa_initials_buckets<sc_lv<32>, 32> *  AESL_inst_nfa_initials_buckets;
sc_signal< sc_dt::sc_lv<32> > bus_nfa_initials_buckets_din;
sc_signal< sc_dt::sc_lv<32> > bus_nfa_initials_buckets_dout;
    AESL_autobus_nfa_finals_buckets<sc_lv<32>, 32> *  AESL_inst_nfa_finals_buckets;
sc_signal< sc_dt::sc_lv<32> > bus_nfa_finals_buckets_din;
sc_signal< sc_dt::sc_lv<32> > bus_nfa_finals_buckets_dout;
    AESL_autobus_nfa_forward_buckets<sc_lv<32>, 32> *  AESL_inst_nfa_forward_buckets;
sc_signal< sc_dt::sc_lv<32> > bus_nfa_forward_buckets_din;
sc_signal< sc_dt::sc_lv<32> > bus_nfa_forward_buckets_dout;
    AESL_autobus_sample_buffer<sc_lv<8>, 8> *  AESL_inst_sample_buffer;
sc_signal< sc_dt::sc_lv<8> > bus_sample_buffer_din;
sc_signal< sc_dt::sc_lv<8> > bus_sample_buffer_dout;
    AESL_autobus_indices_begin<sc_lv<32>, 32> *  AESL_inst_indices_begin;
sc_signal< sc_dt::sc_lv<32> > bus_indices_begin_din;
sc_signal< sc_dt::sc_lv<32> > bus_indices_begin_dout;
    AESL_autobus_indices_samples<sc_lv<16>, 16> *  AESL_inst_indices_samples;
sc_signal< sc_dt::sc_lv<16> > bus_indices_samples_din;
sc_signal< sc_dt::sc_lv<16> > bus_indices_samples_dout;
    AESL_autobus_indices_stride<sc_lv<8>, 8> *  AESL_inst_indices_stride;
sc_signal< sc_dt::sc_lv<8> > bus_indices_stride_din;
sc_signal< sc_dt::sc_lv<8> > bus_indices_stride_dout;

AESL_FILE_HANDLER AESL_fh;
    ifstream AESL_mTvIn;
    ifstream AESL_mTvOut;
    ofstream AESL_mHdlTvIn;
    ofstream AESL_mHdlTvOut;
    int AESL_mErrNo;
    int AESL_mTransNo;
    ofstream AESL_mErrLog;
    ofstream AESL_mParamLog;

    int AESL_mLatCnter;
    int AESL_mLatCnterInIdx;
    int* AESL_mLatCnterIn;
    int* AESL_mLatCnterOut;
    int* AESL_lat_array;
    int* AESL_thr_array;
    int AESL_mLatCnterOutIdx;
    int AESL_done_cnt;
    int AESL_ready_cnt;

    bool AESL_mFinishTvOut_ap_return;


    void AESL_proc_tv_in();
    void AESL_proc_transaction_ready();
    void AESL_proc_interface_done();
    void AESL_proc_transaction_ready_nfa_initials_buckets();
    void AESL_proc_transaction_done_nfa_initials_buckets();
    void AESL_proc_transaction_ready_nfa_finals_buckets();
    void AESL_proc_transaction_done_nfa_finals_buckets();
    void AESL_proc_transaction_ready_nfa_forward_buckets();
    void AESL_proc_transaction_done_nfa_forward_buckets();
    void AESL_proc_transaction_ready_nfa_backward_buckets();
    void AESL_proc_transaction_done_nfa_backward_buckets();
    void AESL_proc_transaction_ready_nfa_symbols();
    void AESL_proc_transaction_done_nfa_symbols();
    void AESL_proc_transaction_ready_sample_buffer();
    void AESL_proc_transaction_done_sample_buffer();
    void AESL_proc_transaction_ready_sample_buffer_length();
    void AESL_proc_transaction_done_sample_buffer_length();
    void AESL_proc_transaction_ready_sample_length();
    void AESL_proc_transaction_done_sample_length();
    void AESL_proc_transaction_ready_indices_begin();
    void AESL_proc_transaction_done_indices_begin();
    void AESL_proc_transaction_ready_indices_samples();
    void AESL_proc_transaction_done_indices_samples();
    void AESL_proc_transaction_ready_indices_stride();
    void AESL_proc_transaction_done_indices_stride();
    void AESL_proc_transaction_ready_i_size();
    void AESL_proc_transaction_done_i_size();
    void AESL_proc_transaction_ready_begin_index();
    void AESL_proc_transaction_done_begin_index();
    void AESL_proc_transaction_ready_begin_sample();
    void AESL_proc_transaction_done_begin_sample();
    void AESL_proc_transaction_ready_end_index();
    void AESL_proc_transaction_done_end_index();
    void AESL_proc_transaction_ready_end_sample();
    void AESL_proc_transaction_done_end_sample();
    void AESL_proc_transaction_ready_stop_on_first();
    void AESL_proc_transaction_done_stop_on_first();
    void AESL_proc_transaction_ready_accept();
    void AESL_proc_transaction_done_accept();
    void AESL_proc_ready_delay();
    void AESL_proc_done_delay();
    void AESL_proc_initial_ready();
    void AESL_proc_ready_cnt();
    void AESL_proc_tv_out();
    void AESL_proc_mlatcnterin();
    void AESL_proc_mlatcnterout();
    void AESL_proc_calculate_performance();
    void AESL_proc_tv_in_nfa_initials_buckets();
    void AESL_proc_tv_in_nfa_finals_buckets();
    void AESL_proc_tv_in_nfa_forward_buckets();
    void AESL_proc_tv_in_nfa_symbols();
    void AESL_proc_tv_in_sample_buffer();
    void AESL_proc_tv_in_sample_buffer_length();
    void AESL_proc_tv_in_sample_length();
    void AESL_proc_tv_in_indices_begin();
    void AESL_proc_tv_in_indices_samples();
    void AESL_proc_tv_in_indices_stride();
    void AESL_proc_tv_in_begin_index();
    void AESL_proc_tv_in_begin_sample();
    void AESL_proc_tv_in_end_index();
    void AESL_proc_tv_in_end_sample();
    void AESL_proc_tv_in_stop_on_first();
    void AESL_proc_tv_in_accept();
    void AESL_proc_tv_out_ap_return();
    void AESL_proc_cnter();
    bool AESL_proc_split_tv();
    void AESL_proc_buffer_output();

#if defined(AESL_APATB_ALDEC)
    void AESL_proc_clock_bool() {
        if (AESL_clock.read() == SC_LOGIC_1)
            AESL_clock_bool.write(true);
        else
            AESL_clock_bool.write(false);
    }
#endif


    void AESL_proc_connection_busnfa_initials_buckets_din();
    void AESL_proc_connection_busnfa_initials_buckets_dout();
    void AESL_proc_connection_busnfa_finals_buckets_din();
    void AESL_proc_connection_busnfa_finals_buckets_dout();
    void AESL_proc_connection_busnfa_forward_buckets_din();
    void AESL_proc_connection_busnfa_forward_buckets_dout();
    void AESL_proc_connection_bussample_buffer_din();
    void AESL_proc_connection_bussample_buffer_dout();
    void AESL_proc_connection_busindices_begin_din();
    void AESL_proc_connection_busindices_begin_dout();
    void AESL_proc_connection_busindices_samples_din();
    void AESL_proc_connection_busindices_samples_dout();
    void AESL_proc_connection_busindices_stride_din();
    void AESL_proc_connection_busindices_stride_dout();

    ~AUTOTB_TOP()
    {
        if (AESL_mErrNo != 0) {
            AESL_mErrLog << "AESL_mErrNo = " << AESL_mErrNo << endl;
        }
        AESL_mErrLog.close();
        AESL_mParamLog.close();
        AESL_mTvIn.close();
        AESL_mTvOut.close();
        AESL_mHdlTvIn.close();
        AESL_mHdlTvOut.close();
        delete AESL_mLatCnterIn;
        delete AESL_mLatCnterOut;
        delete AESL_lat_array;
        delete AESL_thr_array;
        delete AUTOTB_DUT_INST;
    }

    SC_CTOR(AUTOTB_TOP)
    {
        AESL_mErrNo = 0;
        AESL_mTransNo = AUTOTB_TRANSACTION_NUM;
        AESL_mErrLog.open("err.log");
        AESL_mParamLog.open("param.log");
        AESL_mLatCnterIn    = new int[AUTOTB_TRANSACTION_NUM + 1];
        AESL_mLatCnterOut   = new int[AUTOTB_TRANSACTION_NUM + 1];
        AESL_lat_array      = new int[AUTOTB_TRANSACTION_NUM + 1];
        AESL_thr_array      = new int[AUTOTB_TRANSACTION_NUM + 1];


        AESL_mLatCnter = 0;
        AESL_mLatCnterInIdx = 0;
        AESL_mLatCnterOutIdx = 0;
        AESL_done_cnt = 0;

        AESL_mFinishTvOut_ap_return = false;

        AESL_mHdlTvIn.open(AUTOTB_HDL_TVIN);
        AESL_mHdlTvOut.open(AUTOTB_HDL_TVOUT);

        if (!AESL_mHdlTvIn.good()
            || !AESL_mHdlTvOut.good()
        ) {
            AESL_mErrNo = 1;
            sc_stop();
            return;
        }
    
        AUTOTB_DUT_INST = new AUTOTB_DUT("AUTOTB_DUT_INST");
        AUTOTB_DUT_INST->ap_clk( AESL_clock );
        AUTOTB_DUT_INST->ap_rst( AESL_reset );
        AUTOTB_DUT_INST->ap_start( AESL_start );
        AUTOTB_DUT_INST->ap_done( AESL_done );
        AUTOTB_DUT_INST->ap_idle( AESL_idle );
        AUTOTB_DUT_INST->ap_ready( AESL_ready );
        AUTOTB_DUT_INST->nfa_initials_buckets_req_din( nfa_initials_buckets_req_din );
        AUTOTB_DUT_INST->nfa_initials_buckets_req_full_n( nfa_initials_buckets_req_full_n );
        AUTOTB_DUT_INST->nfa_initials_buckets_req_write( nfa_initials_buckets_req_write );
        AUTOTB_DUT_INST->nfa_initials_buckets_rsp_empty_n( nfa_initials_buckets_rsp_empty_n );
        AUTOTB_DUT_INST->nfa_initials_buckets_rsp_read( nfa_initials_buckets_rsp_read );
        AUTOTB_DUT_INST->nfa_initials_buckets_address( nfa_initials_buckets_address );
        AUTOTB_DUT_INST->nfa_initials_buckets_datain( nfa_initials_buckets_datain );
        AUTOTB_DUT_INST->nfa_initials_buckets_dataout( nfa_initials_buckets_dataout );
        AUTOTB_DUT_INST->nfa_initials_buckets_size( nfa_initials_buckets_size );
        AUTOTB_DUT_INST->nfa_finals_buckets_req_din( nfa_finals_buckets_req_din );
        AUTOTB_DUT_INST->nfa_finals_buckets_req_full_n( nfa_finals_buckets_req_full_n );
        AUTOTB_DUT_INST->nfa_finals_buckets_req_write( nfa_finals_buckets_req_write );
        AUTOTB_DUT_INST->nfa_finals_buckets_rsp_empty_n( nfa_finals_buckets_rsp_empty_n );
        AUTOTB_DUT_INST->nfa_finals_buckets_rsp_read( nfa_finals_buckets_rsp_read );
        AUTOTB_DUT_INST->nfa_finals_buckets_address( nfa_finals_buckets_address );
        AUTOTB_DUT_INST->nfa_finals_buckets_datain( nfa_finals_buckets_datain );
        AUTOTB_DUT_INST->nfa_finals_buckets_dataout( nfa_finals_buckets_dataout );
        AUTOTB_DUT_INST->nfa_finals_buckets_size( nfa_finals_buckets_size );
        AUTOTB_DUT_INST->nfa_forward_buckets_req_din( nfa_forward_buckets_req_din );
        AUTOTB_DUT_INST->nfa_forward_buckets_req_full_n( nfa_forward_buckets_req_full_n );
        AUTOTB_DUT_INST->nfa_forward_buckets_req_write( nfa_forward_buckets_req_write );
        AUTOTB_DUT_INST->nfa_forward_buckets_rsp_empty_n( nfa_forward_buckets_rsp_empty_n );
        AUTOTB_DUT_INST->nfa_forward_buckets_rsp_read( nfa_forward_buckets_rsp_read );
        AUTOTB_DUT_INST->nfa_forward_buckets_address( nfa_forward_buckets_address );
        AUTOTB_DUT_INST->nfa_forward_buckets_datain( nfa_forward_buckets_datain );
        AUTOTB_DUT_INST->nfa_forward_buckets_dataout( nfa_forward_buckets_dataout );
        AUTOTB_DUT_INST->nfa_forward_buckets_size( nfa_forward_buckets_size );
        AUTOTB_DUT_INST->nfa_symbols( nfa_symbols );
        AUTOTB_DUT_INST->sample_buffer_req_din( sample_buffer_req_din );
        AUTOTB_DUT_INST->sample_buffer_req_full_n( sample_buffer_req_full_n );
        AUTOTB_DUT_INST->sample_buffer_req_write( sample_buffer_req_write );
        AUTOTB_DUT_INST->sample_buffer_rsp_empty_n( sample_buffer_rsp_empty_n );
        AUTOTB_DUT_INST->sample_buffer_rsp_read( sample_buffer_rsp_read );
        AUTOTB_DUT_INST->sample_buffer_address( sample_buffer_address );
        AUTOTB_DUT_INST->sample_buffer_datain( sample_buffer_datain );
        AUTOTB_DUT_INST->sample_buffer_dataout( sample_buffer_dataout );
        AUTOTB_DUT_INST->sample_buffer_size( sample_buffer_size );
        AUTOTB_DUT_INST->sample_buffer_length( sample_buffer_length );
        AUTOTB_DUT_INST->sample_length( sample_length );
        AUTOTB_DUT_INST->indices_begin_req_din( indices_begin_req_din );
        AUTOTB_DUT_INST->indices_begin_req_full_n( indices_begin_req_full_n );
        AUTOTB_DUT_INST->indices_begin_req_write( indices_begin_req_write );
        AUTOTB_DUT_INST->indices_begin_rsp_empty_n( indices_begin_rsp_empty_n );
        AUTOTB_DUT_INST->indices_begin_rsp_read( indices_begin_rsp_read );
        AUTOTB_DUT_INST->indices_begin_address( indices_begin_address );
        AUTOTB_DUT_INST->indices_begin_datain( indices_begin_datain );
        AUTOTB_DUT_INST->indices_begin_dataout( indices_begin_dataout );
        AUTOTB_DUT_INST->indices_begin_size( indices_begin_size );
        AUTOTB_DUT_INST->indices_samples_req_din( indices_samples_req_din );
        AUTOTB_DUT_INST->indices_samples_req_full_n( indices_samples_req_full_n );
        AUTOTB_DUT_INST->indices_samples_req_write( indices_samples_req_write );
        AUTOTB_DUT_INST->indices_samples_rsp_empty_n( indices_samples_rsp_empty_n );
        AUTOTB_DUT_INST->indices_samples_rsp_read( indices_samples_rsp_read );
        AUTOTB_DUT_INST->indices_samples_address( indices_samples_address );
        AUTOTB_DUT_INST->indices_samples_datain( indices_samples_datain );
        AUTOTB_DUT_INST->indices_samples_dataout( indices_samples_dataout );
        AUTOTB_DUT_INST->indices_samples_size( indices_samples_size );
        AUTOTB_DUT_INST->indices_stride_req_din( indices_stride_req_din );
        AUTOTB_DUT_INST->indices_stride_req_full_n( indices_stride_req_full_n );
        AUTOTB_DUT_INST->indices_stride_req_write( indices_stride_req_write );
        AUTOTB_DUT_INST->indices_stride_rsp_empty_n( indices_stride_rsp_empty_n );
        AUTOTB_DUT_INST->indices_stride_rsp_read( indices_stride_rsp_read );
        AUTOTB_DUT_INST->indices_stride_address( indices_stride_address );
        AUTOTB_DUT_INST->indices_stride_datain( indices_stride_datain );
        AUTOTB_DUT_INST->indices_stride_dataout( indices_stride_dataout );
        AUTOTB_DUT_INST->indices_stride_size( indices_stride_size );
        AUTOTB_DUT_INST->i_size( i_size );
        AUTOTB_DUT_INST->begin_index( begin_index );
        AUTOTB_DUT_INST->begin_sample( begin_sample );
        AUTOTB_DUT_INST->end_index( end_index );
        AUTOTB_DUT_INST->end_sample( end_sample );
        AUTOTB_DUT_INST->stop_on_first( stop_on_first );
        AUTOTB_DUT_INST->accept( accept );
        AUTOTB_DUT_INST->ap_return( ap_return );

        AESL_inst_nfa_initials_buckets = new  AESL_autobus_nfa_initials_buckets<sc_lv<32>, 32>("AESL_inst_nfa_initials_buckets");
#if defined(AESL_APATB_ALDEC)
        AESL_inst_nfa_initials_buckets->clk(AESL_clock_bool);
#endif
#if !defined(AESL_APATB_ALDEC)
        AESL_inst_nfa_initials_buckets->clk(AESL_clock);
#endif
        AESL_inst_nfa_initials_buckets->reset(AESL_reset);
        AESL_inst_nfa_initials_buckets->bus_req_din( nfa_initials_buckets_req_din );
        AESL_inst_nfa_initials_buckets->bus_req_full_n( nfa_initials_buckets_req_full_n );
        AESL_inst_nfa_initials_buckets->bus_req_write( nfa_initials_buckets_req_write );
        AESL_inst_nfa_initials_buckets->bus_rsp_empty_n( nfa_initials_buckets_rsp_empty_n );
        AESL_inst_nfa_initials_buckets->bus_rsp_read( nfa_initials_buckets_rsp_read );
        AESL_inst_nfa_initials_buckets->bus_address( nfa_initials_buckets_address );
        AESL_inst_nfa_initials_buckets->bus_datain( bus_nfa_initials_buckets_dout );
        AESL_inst_nfa_initials_buckets->bus_dataout( bus_nfa_initials_buckets_din );
        AESL_inst_nfa_initials_buckets->bus_size( nfa_initials_buckets_size );

        AESL_inst_nfa_finals_buckets = new  AESL_autobus_nfa_finals_buckets<sc_lv<32>, 32>("AESL_inst_nfa_finals_buckets");
#if defined(AESL_APATB_ALDEC)
        AESL_inst_nfa_finals_buckets->clk(AESL_clock_bool);
#endif
#if !defined(AESL_APATB_ALDEC)
        AESL_inst_nfa_finals_buckets->clk(AESL_clock);
#endif
        AESL_inst_nfa_finals_buckets->reset(AESL_reset);
        AESL_inst_nfa_finals_buckets->bus_req_din( nfa_finals_buckets_req_din );
        AESL_inst_nfa_finals_buckets->bus_req_full_n( nfa_finals_buckets_req_full_n );
        AESL_inst_nfa_finals_buckets->bus_req_write( nfa_finals_buckets_req_write );
        AESL_inst_nfa_finals_buckets->bus_rsp_empty_n( nfa_finals_buckets_rsp_empty_n );
        AESL_inst_nfa_finals_buckets->bus_rsp_read( nfa_finals_buckets_rsp_read );
        AESL_inst_nfa_finals_buckets->bus_address( nfa_finals_buckets_address );
        AESL_inst_nfa_finals_buckets->bus_datain( bus_nfa_finals_buckets_dout );
        AESL_inst_nfa_finals_buckets->bus_dataout( bus_nfa_finals_buckets_din );
        AESL_inst_nfa_finals_buckets->bus_size( nfa_finals_buckets_size );

        AESL_inst_nfa_forward_buckets = new  AESL_autobus_nfa_forward_buckets<sc_lv<32>, 32>("AESL_inst_nfa_forward_buckets");
#if defined(AESL_APATB_ALDEC)
        AESL_inst_nfa_forward_buckets->clk(AESL_clock_bool);
#endif
#if !defined(AESL_APATB_ALDEC)
        AESL_inst_nfa_forward_buckets->clk(AESL_clock);
#endif
        AESL_inst_nfa_forward_buckets->reset(AESL_reset);
        AESL_inst_nfa_forward_buckets->bus_req_din( nfa_forward_buckets_req_din );
        AESL_inst_nfa_forward_buckets->bus_req_full_n( nfa_forward_buckets_req_full_n );
        AESL_inst_nfa_forward_buckets->bus_req_write( nfa_forward_buckets_req_write );
        AESL_inst_nfa_forward_buckets->bus_rsp_empty_n( nfa_forward_buckets_rsp_empty_n );
        AESL_inst_nfa_forward_buckets->bus_rsp_read( nfa_forward_buckets_rsp_read );
        AESL_inst_nfa_forward_buckets->bus_address( nfa_forward_buckets_address );
        AESL_inst_nfa_forward_buckets->bus_datain( bus_nfa_forward_buckets_dout );
        AESL_inst_nfa_forward_buckets->bus_dataout( bus_nfa_forward_buckets_din );
        AESL_inst_nfa_forward_buckets->bus_size( nfa_forward_buckets_size );

        AESL_inst_sample_buffer = new  AESL_autobus_sample_buffer<sc_lv<8>, 8>("AESL_inst_sample_buffer");
#if defined(AESL_APATB_ALDEC)
        AESL_inst_sample_buffer->clk(AESL_clock_bool);
#endif
#if !defined(AESL_APATB_ALDEC)
        AESL_inst_sample_buffer->clk(AESL_clock);
#endif
        AESL_inst_sample_buffer->reset(AESL_reset);
        AESL_inst_sample_buffer->bus_req_din( sample_buffer_req_din );
        AESL_inst_sample_buffer->bus_req_full_n( sample_buffer_req_full_n );
        AESL_inst_sample_buffer->bus_req_write( sample_buffer_req_write );
        AESL_inst_sample_buffer->bus_rsp_empty_n( sample_buffer_rsp_empty_n );
        AESL_inst_sample_buffer->bus_rsp_read( sample_buffer_rsp_read );
        AESL_inst_sample_buffer->bus_address( sample_buffer_address );
        AESL_inst_sample_buffer->bus_datain( bus_sample_buffer_dout );
        AESL_inst_sample_buffer->bus_dataout( bus_sample_buffer_din );
        AESL_inst_sample_buffer->bus_size( sample_buffer_size );

        AESL_inst_indices_begin = new  AESL_autobus_indices_begin<sc_lv<32>, 32>("AESL_inst_indices_begin");
#if defined(AESL_APATB_ALDEC)
        AESL_inst_indices_begin->clk(AESL_clock_bool);
#endif
#if !defined(AESL_APATB_ALDEC)
        AESL_inst_indices_begin->clk(AESL_clock);
#endif
        AESL_inst_indices_begin->reset(AESL_reset);
        AESL_inst_indices_begin->bus_req_din( indices_begin_req_din );
        AESL_inst_indices_begin->bus_req_full_n( indices_begin_req_full_n );
        AESL_inst_indices_begin->bus_req_write( indices_begin_req_write );
        AESL_inst_indices_begin->bus_rsp_empty_n( indices_begin_rsp_empty_n );
        AESL_inst_indices_begin->bus_rsp_read( indices_begin_rsp_read );
        AESL_inst_indices_begin->bus_address( indices_begin_address );
        AESL_inst_indices_begin->bus_datain( bus_indices_begin_dout );
        AESL_inst_indices_begin->bus_dataout( bus_indices_begin_din );
        AESL_inst_indices_begin->bus_size( indices_begin_size );

        AESL_inst_indices_samples = new  AESL_autobus_indices_samples<sc_lv<16>, 16>("AESL_inst_indices_samples");
#if defined(AESL_APATB_ALDEC)
        AESL_inst_indices_samples->clk(AESL_clock_bool);
#endif
#if !defined(AESL_APATB_ALDEC)
        AESL_inst_indices_samples->clk(AESL_clock);
#endif
        AESL_inst_indices_samples->reset(AESL_reset);
        AESL_inst_indices_samples->bus_req_din( indices_samples_req_din );
        AESL_inst_indices_samples->bus_req_full_n( indices_samples_req_full_n );
        AESL_inst_indices_samples->bus_req_write( indices_samples_req_write );
        AESL_inst_indices_samples->bus_rsp_empty_n( indices_samples_rsp_empty_n );
        AESL_inst_indices_samples->bus_rsp_read( indices_samples_rsp_read );
        AESL_inst_indices_samples->bus_address( indices_samples_address );
        AESL_inst_indices_samples->bus_datain( bus_indices_samples_dout );
        AESL_inst_indices_samples->bus_dataout( bus_indices_samples_din );
        AESL_inst_indices_samples->bus_size( indices_samples_size );

        AESL_inst_indices_stride = new  AESL_autobus_indices_stride<sc_lv<8>, 8>("AESL_inst_indices_stride");
#if defined(AESL_APATB_ALDEC)
        AESL_inst_indices_stride->clk(AESL_clock_bool);
#endif
#if !defined(AESL_APATB_ALDEC)
        AESL_inst_indices_stride->clk(AESL_clock);
#endif
        AESL_inst_indices_stride->reset(AESL_reset);
        AESL_inst_indices_stride->bus_req_din( indices_stride_req_din );
        AESL_inst_indices_stride->bus_req_full_n( indices_stride_req_full_n );
        AESL_inst_indices_stride->bus_req_write( indices_stride_req_write );
        AESL_inst_indices_stride->bus_rsp_empty_n( indices_stride_rsp_empty_n );
        AESL_inst_indices_stride->bus_rsp_read( indices_stride_rsp_read );
        AESL_inst_indices_stride->bus_address( indices_stride_address );
        AESL_inst_indices_stride->bus_datain( bus_indices_stride_dout );
        AESL_inst_indices_stride->bus_dataout( bus_indices_stride_din );
        AESL_inst_indices_stride->bus_size( indices_stride_size );

        SC_METHOD(AESL_proc_transaction_ready_nfa_initials_buckets);
        sensitive << AESL_transaction_ready;


        SC_METHOD(AESL_proc_transaction_ready_nfa_finals_buckets);
        sensitive << AESL_transaction_ready;


        SC_METHOD(AESL_proc_transaction_ready_nfa_forward_buckets);
        sensitive << AESL_transaction_ready;



        SC_METHOD(AESL_proc_transaction_done_nfa_backward_buckets);
        sensitive << AESL_reset;

        SC_METHOD(AESL_proc_transaction_ready_nfa_symbols);
        sensitive << AESL_transaction_ready;


        SC_METHOD(AESL_proc_transaction_ready_sample_buffer);
        sensitive << AESL_transaction_ready;


        SC_METHOD(AESL_proc_transaction_ready_sample_buffer_length);
        sensitive << AESL_transaction_ready;

        SC_METHOD(AESL_proc_transaction_done_sample_buffer_length);
        sensitive << AESL_done_delay;

        SC_METHOD(AESL_proc_transaction_ready_sample_length);
        sensitive << AESL_transaction_ready;

        SC_METHOD(AESL_proc_transaction_done_sample_length);
        sensitive << AESL_done_delay;

        SC_METHOD(AESL_proc_transaction_ready_indices_begin);
        sensitive << AESL_transaction_ready;


        SC_METHOD(AESL_proc_transaction_ready_indices_samples);
        sensitive << AESL_transaction_ready;


        SC_METHOD(AESL_proc_transaction_ready_indices_stride);
        sensitive << AESL_transaction_ready;


        SC_METHOD(AESL_proc_transaction_ready_i_size);
        sensitive << AESL_transaction_ready;

        SC_METHOD(AESL_proc_transaction_done_i_size);
        sensitive << AESL_done_delay;

        SC_METHOD(AESL_proc_transaction_ready_begin_index);
        sensitive << AESL_transaction_ready;

        SC_METHOD(AESL_proc_transaction_done_begin_index);
        sensitive << AESL_done_delay;

        SC_METHOD(AESL_proc_transaction_ready_begin_sample);
        sensitive << AESL_transaction_ready;

        SC_METHOD(AESL_proc_transaction_done_begin_sample);
        sensitive << AESL_done_delay;

        SC_METHOD(AESL_proc_transaction_ready_end_index);
        sensitive << AESL_transaction_ready;

        SC_METHOD(AESL_proc_transaction_done_end_index);
        sensitive << AESL_done_delay;

        SC_METHOD(AESL_proc_transaction_ready_end_sample);
        sensitive << AESL_transaction_ready;

        SC_METHOD(AESL_proc_transaction_done_end_sample);
        sensitive << AESL_done_delay;

        SC_METHOD(AESL_proc_transaction_ready_stop_on_first);
        sensitive << AESL_transaction_ready;

        SC_METHOD(AESL_proc_transaction_done_stop_on_first);
        sensitive << AESL_done_delay;

        SC_METHOD(AESL_proc_transaction_ready_accept);
        sensitive << AESL_transaction_ready;

        SC_METHOD(AESL_proc_transaction_done_accept);
        sensitive << AESL_done_delay;

        SC_METHOD(AESL_proc_ready_delay);
        sensitive << AESL_clock.pos() << AESL_reset;

        SC_METHOD(AESL_proc_done_delay);
        sensitive << AESL_clock.pos() << AESL_reset;

        SC_THREAD(AESL_proc_interface_done);
        sensitive << AESL_clock.pos() << AESL_reset;

        SC_METHOD(AESL_proc_transaction_ready);
        sensitive << AESL_initial_ready << AESL_ready_delay;

        SC_THREAD(AESL_proc_initial_ready);
        sensitive << AESL_clock.pos();

        SC_METHOD(AESL_proc_ready_cnt);
        sensitive << AESL_transaction_ready;

        SC_THREAD(AESL_proc_tv_in);
        sensitive << AESL_clock.pos();

        SC_THREAD(AESL_proc_tv_out);
        sensitive << AESL_clock.pos();

        SC_METHOD(AESL_proc_mlatcnterin);
        sensitive << AESL_clock.pos() << AESL_reset;

        SC_METHOD(AESL_proc_mlatcnterout);
        sensitive << AESL_clock.pos() << AESL_reset;

        SC_THREAD(AESL_proc_calculate_performance);
        sensitive << AESL_clock.pos();

        SC_THREAD(AESL_proc_tv_in_nfa_initials_buckets);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_in_nfa_finals_buckets);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_in_nfa_forward_buckets);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_in_nfa_symbols);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_in_sample_buffer);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_in_sample_buffer_length);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_in_sample_length);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_in_indices_begin);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_in_indices_samples);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_in_indices_stride);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_in_begin_index);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_in_begin_sample);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_in_end_index);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_in_end_sample);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_in_stop_on_first);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_in_accept);
         sensitive << AESL_clock.pos();


        SC_THREAD(AESL_proc_tv_out_ap_return);
         sensitive << AESL_clock.pos();


        SC_METHOD(AESL_proc_cnter);
        sensitive << AESL_clock.pos();


        SC_METHOD(AESL_proc_connection_busnfa_initials_buckets_din);
        sensitive << nfa_initials_buckets_dataout;
        SC_METHOD(AESL_proc_connection_busnfa_initials_buckets_dout);
        sensitive << bus_nfa_initials_buckets_dout;
        SC_METHOD(AESL_proc_connection_busnfa_finals_buckets_din);
        sensitive << nfa_finals_buckets_dataout;
        SC_METHOD(AESL_proc_connection_busnfa_finals_buckets_dout);
        sensitive << bus_nfa_finals_buckets_dout;
        SC_METHOD(AESL_proc_connection_busnfa_forward_buckets_din);
        sensitive << nfa_forward_buckets_dataout;
        SC_METHOD(AESL_proc_connection_busnfa_forward_buckets_dout);
        sensitive << bus_nfa_forward_buckets_dout;
        SC_METHOD(AESL_proc_connection_bussample_buffer_din);
        sensitive << sample_buffer_dataout;
        SC_METHOD(AESL_proc_connection_bussample_buffer_dout);
        sensitive << bus_sample_buffer_dout;
        SC_METHOD(AESL_proc_connection_busindices_begin_din);
        sensitive << indices_begin_dataout;
        SC_METHOD(AESL_proc_connection_busindices_begin_dout);
        sensitive << bus_indices_begin_dout;
        SC_METHOD(AESL_proc_connection_busindices_samples_din);
        sensitive << indices_samples_dataout;
        SC_METHOD(AESL_proc_connection_busindices_samples_dout);
        sensitive << bus_indices_samples_dout;
        SC_METHOD(AESL_proc_connection_busindices_stride_din);
        sensitive << indices_stride_dataout;
        SC_METHOD(AESL_proc_connection_busindices_stride_dout);
        sensitive << bus_indices_stride_dout;
        SC_METHOD(AESL_proc_buffer_output);
        sensitive << AESL_clock.pos();

#if defined(AESL_APATB_ALDEC)
        SC_METHOD(AESL_proc_clock_bool);
        sensitive << AESL_clock;
#endif

    }

};


void AUTOTB_TOP::AESL_proc_buffer_output()
{
    if (0) {
        AESL_BUFF_ap_return.write(sc_lv<32>());
    }
    else if (AESL_done.read() == SC_LOGIC_1) {
        AESL_BUFF_ap_return.write(ap_return.read());
    }
}


void AUTOTB_TOP::AESL_proc_cnter()
{
    AESL_mLatCnter ++;
}


void AUTOTB_TOP::AESL_proc_tv_in()
{
    int wait_i;
    AESL_start.write(SC_LOGIC_0);
    AESL_ce.write(SC_LOGIC_1);
    AESL_continue.write(SC_LOGIC_1);
    AESL_reset.write(SC_LOGIC_1);
    wait();
    wait(4);
    AESL_reset.write(SC_LOGIC_0);

    wait();
    wait(10, SC_PS);
    AESL_start.write(SC_LOGIC_1);
    while (AESL_done_cnt < AUTOTB_TRANSACTION_NUM + 1) {
        wait();
    }
    AESL_start.write(SC_LOGIC_0);

}


void AUTOTB_TOP::AESL_proc_tv_out()
{
    wait();
    wait(4);

    while (1) {

        while (AESL_start.read() != SC_LOGIC_1)  wait();
        wait();

        unsigned AESL_latency = 0;
        bool AESL_timeout = false;
        if (true
            && AESL_mFinishTvOut_ap_return
        ) {
            break;
        }

    }

    wait(10, SC_PS);
    sc_stop();
}


void AUTOTB_TOP::AESL_proc_mlatcnterin()
{
    if(AESL_reset.read() == SC_LOGIC_1) 
    {
        AESL_mLatCnterInIdx = 0;
    }
    else {
        if (AESL_start.read() == SC_LOGIC_1 && AESL_mLatCnterInIdx == 0) {
            AESL_mLatCnterIn[AESL_mLatCnterInIdx++] = AESL_mLatCnter;
        }
        if (AESL_ready.read() == SC_LOGIC_1 && AESL_mLatCnterInIdx < AUTOTB_TRANSACTION_NUM + 1 ) {
            AESL_mLatCnterIn[AESL_mLatCnterInIdx++] = AESL_mLatCnter;
        }
    }
}

void AUTOTB_TOP::AESL_proc_mlatcnterout()
{
    if(AESL_reset.read() == SC_LOGIC_1) 
    {
        AESL_mLatCnterOutIdx = 0;
        AESL_mLatCnterOut[AESL_mLatCnterOutIdx] = AESL_mLatCnter + 1;
        AESL_done_cnt = 0;
    }
    else if (AESL_done.read() == SC_LOGIC_1 && AESL_mLatCnterOutIdx < AUTOTB_TRANSACTION_NUM + 1 ) {
        AESL_mLatCnterOut[AESL_mLatCnterOutIdx++] = AESL_mLatCnter;
        AESL_done_cnt ++;
    }
}

void AUTOTB_TOP::AESL_proc_calculate_performance()
{
    wait();
    wait(4);

    while (1) {

        wait();

        bool AESL_timeout = false;
        if (true
            && AESL_mFinishTvOut_ap_return
        ) {
            break;
        }

    }
    wait (1 , SC_PS);
    //////calculate latency/throught
    int AESL_tmp_latthistime;
    int AESL_tmp_lattotal = 0;
    int AESL_tmp_latmax = 0;
    int AESL_tmp_latmin = 0x7fffffff;
    int AESL_tmp_lataver;
    int AESL_tmp_thrthistime;
    int AESL_tmp_thrtotal = 0;
    int AESL_tmp_thrmax = 0;
    int AESL_tmp_thrmin = 0x7fffffff;
    int AESL_tmp_thraver;

    if (AESL_mLatCnterInIdx == 1 || AESL_mLatCnterInIdx == 0 ) {
        AESL_tmp_latmax  = 0;
        AESL_tmp_latmin  = 0;
        AESL_tmp_lataver = 0;
        AESL_tmp_thrmax  = 0;
        AESL_tmp_thrmin  = 0;
        AESL_tmp_thraver = 0;
        AESL_lat_array[0] = 0;
        AESL_thr_array[0] = 0;
    }
    else if (AESL_mLatCnterOutIdx == 1 || AESL_mLatCnterOutIdx == 0 ) {
        AESL_tmp_latmax  = AESL_mLatCnterOut[0] - AESL_mLatCnterIn[0];
        AESL_tmp_latmin  = AESL_mLatCnterOut[0] - AESL_mLatCnterIn[0];
        AESL_tmp_lataver = AESL_mLatCnterOut[0] - AESL_mLatCnterIn[0];
        AESL_tmp_thrmax  = AESL_mLatCnterIn[1] - AESL_mLatCnterIn[0] + 1;
        AESL_tmp_thrmin  = AESL_mLatCnterIn[1] - AESL_mLatCnterIn[0] + 1;
        AESL_tmp_thraver = AESL_mLatCnterIn[1] - AESL_mLatCnterIn[0] + 1;
        AESL_lat_array[0] = AESL_tmp_lataver;
        AESL_thr_array[0] = AESL_tmp_thraver;
    }
    else {
//LATENCY
        for (unsigned AESL_tmp_iii = 0; AESL_tmp_iii < AESL_mLatCnterOutIdx; AESL_tmp_iii++) {
            AESL_tmp_latthistime = AESL_mLatCnterOut[AESL_tmp_iii] - AESL_mLatCnterIn[AESL_tmp_iii];
            if ( AESL_tmp_iii > 0) {
                AESL_tmp_latthistime = (AESL_tmp_latthistime - 1 < 0) ? 0 : (AESL_tmp_latthistime - 1);
            }
            AESL_tmp_lattotal += AESL_tmp_latthistime;
            AESL_lat_array[AESL_tmp_iii]  = AESL_tmp_latthistime;
            if (AESL_tmp_latthistime > AESL_tmp_latmax) AESL_tmp_latmax = AESL_tmp_latthistime;
            if (AESL_tmp_latthistime < AESL_tmp_latmin) AESL_tmp_latmin = AESL_tmp_latthistime;
        }
//II
        for (unsigned AESL_tmp_iii = 0; AESL_tmp_iii < ((AESL_mLatCnterInIdx > 0 ) ? AESL_mLatCnterInIdx - 1 : 0); AESL_tmp_iii++) {
            AESL_tmp_thrthistime = AESL_mLatCnterIn[AESL_tmp_iii + 1] - AESL_mLatCnterIn[AESL_tmp_iii];
            if ( AESL_tmp_iii == 0) {
                AESL_tmp_thrthistime = AESL_tmp_thrthistime + 1;
            }
            AESL_tmp_thrtotal += AESL_tmp_thrthistime;
            AESL_thr_array[AESL_tmp_iii]  = AESL_tmp_thrthistime;
            if (AESL_tmp_thrthistime > AESL_tmp_thrmax) AESL_tmp_thrmax = AESL_tmp_thrthistime;
            if (AESL_tmp_thrthistime < AESL_tmp_thrmin) AESL_tmp_thrmin = AESL_tmp_thrthistime;
        }
        AESL_thr_array[AESL_mLatCnterInIdx - 1]  = 0;
        AESL_tmp_lataver = AESL_tmp_lattotal / (AESL_mLatCnterOutIdx);
        AESL_tmp_thraver = AESL_tmp_thrtotal / (AESL_mLatCnterInIdx - 1);
    }

    ofstream AESL_tmp_result_file(AUTOTB_LAT_RESULT_FILE);
    AESL_tmp_result_file << "$MAX_LATENCY = \"" << AESL_tmp_latmax  << "\"\n";
    AESL_tmp_result_file << "$MIN_LATENCY = \"" << AESL_tmp_latmin  << "\"\n";
    AESL_tmp_result_file << "$AVER_LATENCY = \"" << AESL_tmp_lataver  << "\"\n";
    AESL_tmp_result_file << "$MAX_THROUGHPUT = \"" << AESL_tmp_thrmax << "\"\n";
    AESL_tmp_result_file << "$MIN_THROUGHPUT = \"" << AESL_tmp_thrmin << "\"\n";
    AESL_tmp_result_file << "$AVER_THROUGHPUT = \"" << AESL_tmp_thraver << "\"\n";
    AESL_tmp_result_file.close();
    ofstream AESL_tmp_result_trans_file(AUTOTB_PER_RESULT_TRANS_FILE);
    char s[100] = "";
    sprintf (s,"%20s%16s%16s\n","","latency","interval");
    AESL_tmp_result_trans_file << s ;
    for (int i = 0; i < AESL_mLatCnterOutIdx; i++) {
        sprintf (s,"transaction%8d:%16d%16d\n",i ,AESL_lat_array[i],AESL_thr_array[i]);
        AESL_tmp_result_trans_file << s ;
    }
    AESL_tmp_result_trans_file.close();


}
void AUTOTB_TOP::AESL_proc_ready_cnt()
{
    if(AESL_reset.read() == SC_LOGIC_1) 
    {
        AESL_ready_cnt = 0;
    } else if (AESL_transaction_ready == 1 && AESL_ready_cnt <= AUTOTB_TRANSACTION_NUM) {
        AESL_ready_cnt ++;
    }
}
void AUTOTB_TOP::AESL_proc_initial_ready() {
    wait ();
    AESL_initial_ready = SC_LOGIC_0;
    while(AESL_reset.read() == SC_LOGIC_1)
    {
        wait ();
        wait (10, SC_PS);
    }
    wait ();
    AESL_initial_ready = SC_LOGIC_1;

    wait ();
    AESL_initial_ready = SC_LOGIC_0;
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_ready_delay() {
    if(AESL_reset.read() == SC_LOGIC_1) 
    {
       AESL_ready_delay = SC_LOGIC_0;
    } else {
       AESL_ready_delay = AESL_ready;
    }
}

void AUTOTB_TOP::AESL_proc_done_delay() {
    if(AESL_reset.read() == SC_LOGIC_1) 
    {
       AESL_done_delay = SC_LOGIC_0;
    } else {
       AESL_done_delay = AESL_done;
    }
}

void AUTOTB_TOP::AESL_proc_transaction_ready() {
    AESL_transaction_ready = AESL_initial_ready | AESL_ready_delay;
}

void AUTOTB_TOP::AESL_proc_interface_done() {
    wait();
    AESL_interface_done = SC_LOGIC_0;
    while(AESL_reset.read() == SC_LOGIC_1)
    {
        wait();
        wait(10, SC_PS);
    }
    while (1) {
        wait (1, SC_PS);
        if (AESL_transaction_ready == 1 && AESL_ready_cnt > 1 && AESL_ready_cnt <= AUTOTB_TRANSACTION_NUM)
            AESL_interface_done = SC_LOGIC_1;
        else if(AESL_done_delay == 1 && AESL_done_cnt == AUTOTB_TRANSACTION_NUM)
            AESL_interface_done = SC_LOGIC_1;
        else
            AESL_interface_done = SC_LOGIC_0;
        wait();
    }
}

void AUTOTB_TOP::AESL_proc_transaction_ready_nfa_initials_buckets () {
    AESL_transaction_ready_nfa_initials_buckets = AESL_transaction_ready;
}


void AUTOTB_TOP::AESL_proc_transaction_ready_nfa_finals_buckets () {
    AESL_transaction_ready_nfa_finals_buckets = AESL_transaction_ready;
}


void AUTOTB_TOP::AESL_proc_transaction_ready_nfa_forward_buckets () {
    AESL_transaction_ready_nfa_forward_buckets = AESL_transaction_ready;
}



void AUTOTB_TOP::AESL_proc_transaction_done_nfa_backward_buckets () {
    AESL_transaction_done_nfa_backward_buckets = AESL_done_delay;
}

void AUTOTB_TOP::AESL_proc_transaction_ready_nfa_symbols () {
    AESL_transaction_ready_nfa_symbols = AESL_transaction_ready;
}


void AUTOTB_TOP::AESL_proc_transaction_ready_sample_buffer () {
    AESL_transaction_ready_sample_buffer = AESL_transaction_ready;
}


void AUTOTB_TOP::AESL_proc_transaction_ready_sample_buffer_length () {
    AESL_transaction_ready_sample_buffer_length = AESL_transaction_ready;
}

void AUTOTB_TOP::AESL_proc_transaction_done_sample_buffer_length () {
    AESL_transaction_done_sample_buffer_length = AESL_done_delay;
}

void AUTOTB_TOP::AESL_proc_transaction_ready_sample_length () {
    AESL_transaction_ready_sample_length = AESL_transaction_ready;
}

void AUTOTB_TOP::AESL_proc_transaction_done_sample_length () {
    AESL_transaction_done_sample_length = AESL_done_delay;
}

void AUTOTB_TOP::AESL_proc_transaction_ready_indices_begin () {
    AESL_transaction_ready_indices_begin = AESL_transaction_ready;
}


void AUTOTB_TOP::AESL_proc_transaction_ready_indices_samples () {
    AESL_transaction_ready_indices_samples = AESL_transaction_ready;
}


void AUTOTB_TOP::AESL_proc_transaction_ready_indices_stride () {
    AESL_transaction_ready_indices_stride = AESL_transaction_ready;
}


void AUTOTB_TOP::AESL_proc_transaction_ready_i_size () {
    AESL_transaction_ready_i_size = AESL_transaction_ready;
}

void AUTOTB_TOP::AESL_proc_transaction_done_i_size () {
    AESL_transaction_done_i_size = AESL_done_delay;
}

void AUTOTB_TOP::AESL_proc_transaction_ready_begin_index () {
    AESL_transaction_ready_begin_index = AESL_transaction_ready;
}

void AUTOTB_TOP::AESL_proc_transaction_done_begin_index () {
    AESL_transaction_done_begin_index = AESL_done_delay;
}

void AUTOTB_TOP::AESL_proc_transaction_ready_begin_sample () {
    AESL_transaction_ready_begin_sample = AESL_transaction_ready;
}

void AUTOTB_TOP::AESL_proc_transaction_done_begin_sample () {
    AESL_transaction_done_begin_sample = AESL_done_delay;
}

void AUTOTB_TOP::AESL_proc_transaction_ready_end_index () {
    AESL_transaction_ready_end_index = AESL_transaction_ready;
}

void AUTOTB_TOP::AESL_proc_transaction_done_end_index () {
    AESL_transaction_done_end_index = AESL_done_delay;
}

void AUTOTB_TOP::AESL_proc_transaction_ready_end_sample () {
    AESL_transaction_ready_end_sample = AESL_transaction_ready;
}

void AUTOTB_TOP::AESL_proc_transaction_done_end_sample () {
    AESL_transaction_done_end_sample = AESL_done_delay;
}

void AUTOTB_TOP::AESL_proc_transaction_ready_stop_on_first () {
    AESL_transaction_ready_stop_on_first = AESL_transaction_ready;
}

void AUTOTB_TOP::AESL_proc_transaction_done_stop_on_first () {
    AESL_transaction_done_stop_on_first = AESL_done_delay;
}

void AUTOTB_TOP::AESL_proc_transaction_ready_accept () {
    AESL_transaction_ready_accept = AESL_transaction_ready;
}

void AUTOTB_TOP::AESL_proc_transaction_done_accept () {
    AESL_transaction_done_accept = AESL_done_delay;
}

void AUTOTB_TOP::AESL_proc_connection_busnfa_initials_buckets_din() {
  bus_nfa_initials_buckets_din.write(nfa_initials_buckets_dataout);
}
void AUTOTB_TOP::AESL_proc_connection_busnfa_initials_buckets_dout() {
  nfa_initials_buckets_datain.write(bus_nfa_initials_buckets_dout);
}
void AUTOTB_TOP::AESL_proc_connection_busnfa_finals_buckets_din() {
  bus_nfa_finals_buckets_din.write(nfa_finals_buckets_dataout);
}
void AUTOTB_TOP::AESL_proc_connection_busnfa_finals_buckets_dout() {
  nfa_finals_buckets_datain.write(bus_nfa_finals_buckets_dout);
}
void AUTOTB_TOP::AESL_proc_connection_busnfa_forward_buckets_din() {
  bus_nfa_forward_buckets_din.write(nfa_forward_buckets_dataout);
}
void AUTOTB_TOP::AESL_proc_connection_busnfa_forward_buckets_dout() {
  nfa_forward_buckets_datain.write(bus_nfa_forward_buckets_dout);
}
void AUTOTB_TOP::AESL_proc_connection_bussample_buffer_din() {
  bus_sample_buffer_din.write(sample_buffer_dataout);
}
void AUTOTB_TOP::AESL_proc_connection_bussample_buffer_dout() {
  sample_buffer_datain.write(bus_sample_buffer_dout);
}
void AUTOTB_TOP::AESL_proc_connection_busindices_begin_din() {
  bus_indices_begin_din.write(indices_begin_dataout);
}
void AUTOTB_TOP::AESL_proc_connection_busindices_begin_dout() {
  indices_begin_datain.write(bus_indices_begin_dout);
}
void AUTOTB_TOP::AESL_proc_connection_busindices_samples_din() {
  bus_indices_samples_din.write(indices_samples_dataout);
}
void AUTOTB_TOP::AESL_proc_connection_busindices_samples_dout() {
  indices_samples_datain.write(bus_indices_samples_dout);
}
void AUTOTB_TOP::AESL_proc_connection_busindices_stride_din() {
  bus_indices_stride_din.write(indices_stride_dataout);
}
void AUTOTB_TOP::AESL_proc_connection_busindices_stride_dout() {
  indices_stride_datain.write(bus_indices_stride_dout);
}
void AUTOTB_TOP::AESL_proc_tv_in_nfa_initials_buckets()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_nfa_initials_buckets, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_nfa_initials_buckets , exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_nfa_initials_buckets, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_nfa_initials_buckets, AESL_token);
        
        wait();
        wait(20, SC_PS);
        while (AESL_transaction_ready_nfa_initials_buckets == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        sc_lv<32> *mem_nfa_initials_buckets = new sc_lv<32>[2];
        int i = 0;
        while (AESL_token != "[[/transaction]]") {
            sc_lv<1024> AESL_tempval =  AESL_token.c_str();
            mem_nfa_initials_buckets[i] = AESL_tempval;
            i++;
            AESL_fh.read(AUTOTB_TVIN_nfa_initials_buckets, AESL_token);
        }
        AESL_inst_nfa_initials_buckets->set_pool(mem_nfa_initials_buckets, 2);
        delete [] mem_nfa_initials_buckets;
        AESL_fh.read(AUTOTB_TVIN_nfa_initials_buckets, AESL_token);
        
        wait();
        
        wait(10, SC_PS);
    }
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_tv_in_nfa_finals_buckets()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_nfa_finals_buckets, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_nfa_finals_buckets , exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_nfa_finals_buckets, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_nfa_finals_buckets, AESL_token);
        
        wait();
        wait(20, SC_PS);
        while (AESL_transaction_ready_nfa_finals_buckets == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        sc_lv<32> *mem_nfa_finals_buckets = new sc_lv<32>[2];
        int i = 0;
        while (AESL_token != "[[/transaction]]") {
            sc_lv<1024> AESL_tempval =  AESL_token.c_str();
            mem_nfa_finals_buckets[i] = AESL_tempval;
            i++;
            AESL_fh.read(AUTOTB_TVIN_nfa_finals_buckets, AESL_token);
        }
        AESL_inst_nfa_finals_buckets->set_pool(mem_nfa_finals_buckets, 2);
        delete [] mem_nfa_finals_buckets;
        AESL_fh.read(AUTOTB_TVIN_nfa_finals_buckets, AESL_token);
        
        wait();
        
        wait(10, SC_PS);
    }
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_tv_in_nfa_forward_buckets()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_nfa_forward_buckets, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_nfa_forward_buckets , exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_nfa_forward_buckets, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_nfa_forward_buckets, AESL_token);
        
        wait();
        wait(20, SC_PS);
        while (AESL_transaction_ready_nfa_forward_buckets == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        sc_lv<32> *mem_nfa_forward_buckets = new sc_lv<32>[10];
        int i = 0;
        while (AESL_token != "[[/transaction]]") {
            sc_lv<1024> AESL_tempval =  AESL_token.c_str();
            mem_nfa_forward_buckets[i] = AESL_tempval;
            i++;
            AESL_fh.read(AUTOTB_TVIN_nfa_forward_buckets, AESL_token);
        }
        AESL_inst_nfa_forward_buckets->set_pool(mem_nfa_forward_buckets, 10);
        delete [] mem_nfa_forward_buckets;
        AESL_fh.read(AUTOTB_TVIN_nfa_forward_buckets, AESL_token);
        
        wait();
        
        wait(10, SC_PS);
    }
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_tv_in_nfa_symbols()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_nfa_symbols, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_nfa_symbols , exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_nfa_symbols, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_nfa_symbols, AESL_token);
        
        wait(20, SC_PS);
        while (AESL_transaction_ready_nfa_symbols == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        if(AESL_token != "[[/transaction]]") {
            nfa_symbols.write(AESL_token.c_str());
            wait();
            AESL_fh.read(AUTOTB_TVIN_nfa_symbols, AESL_token);
        }
        AESL_fh.read(AUTOTB_TVIN_nfa_symbols, AESL_token);
    }
}

void AUTOTB_TOP::AESL_proc_tv_in_sample_buffer()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_sample_buffer, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_sample_buffer , exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_sample_buffer, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_sample_buffer, AESL_token);
        
        wait();
        wait(20, SC_PS);
        while (AESL_transaction_ready_sample_buffer == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        sc_lv<8> *mem_sample_buffer = new sc_lv<8>[10];
        int i = 0;
        while (AESL_token != "[[/transaction]]") {
            sc_lv<1024> AESL_tempval =  AESL_token.c_str();
            mem_sample_buffer[i] = AESL_tempval;
            i++;
            AESL_fh.read(AUTOTB_TVIN_sample_buffer, AESL_token);
        }
        AESL_inst_sample_buffer->set_pool(mem_sample_buffer, 10);
        delete [] mem_sample_buffer;
        AESL_fh.read(AUTOTB_TVIN_sample_buffer, AESL_token);
        
        wait();
        
        wait(10, SC_PS);
    }
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_tv_in_sample_buffer_length()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_sample_buffer_length, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_sample_buffer_length, exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_sample_buffer_length, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_sample_buffer_length, AESL_token);
        
        wait();
        wait(20, SC_PS);
        while (AESL_transaction_ready_sample_buffer_length == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        while (AESL_token != "[[/transaction]]") {
            sc_lv<1024> AESL_tempval =  AESL_token.c_str();
            sample_buffer_length.write(AESL_tempval);
            AESL_fh.read(AUTOTB_TVIN_sample_buffer_length, AESL_token);
        }
        AESL_fh.read(AUTOTB_TVIN_sample_buffer_length, AESL_token);
        
        
        wait(10, SC_PS);
    }
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_tv_in_sample_length()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_sample_length, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_sample_length, exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_sample_length, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_sample_length, AESL_token);
        
        wait();
        wait(20, SC_PS);
        while (AESL_transaction_ready_sample_length == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        while (AESL_token != "[[/transaction]]") {
            sc_lv<1024> AESL_tempval =  AESL_token.c_str();
            sample_length.write(AESL_tempval);
            AESL_fh.read(AUTOTB_TVIN_sample_length, AESL_token);
        }
        AESL_fh.read(AUTOTB_TVIN_sample_length, AESL_token);
        
        
        wait(10, SC_PS);
    }
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_tv_in_indices_begin()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_indices_begin, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_indices_begin , exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_indices_begin, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_indices_begin, AESL_token);
        
        wait();
        wait(20, SC_PS);
        while (AESL_transaction_ready_indices_begin == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        sc_lv<32> *mem_indices_begin = new sc_lv<32>[10];
        int i = 0;
        while (AESL_token != "[[/transaction]]") {
            sc_lv<1024> AESL_tempval =  AESL_token.c_str();
            mem_indices_begin[i] = AESL_tempval;
            i++;
            AESL_fh.read(AUTOTB_TVIN_indices_begin, AESL_token);
        }
        AESL_inst_indices_begin->set_pool(mem_indices_begin, 10);
        delete [] mem_indices_begin;
        AESL_fh.read(AUTOTB_TVIN_indices_begin, AESL_token);
        
        wait();
        
        wait(10, SC_PS);
    }
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_tv_in_indices_samples()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_indices_samples, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_indices_samples , exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_indices_samples, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_indices_samples, AESL_token);
        
        wait();
        wait(20, SC_PS);
        while (AESL_transaction_ready_indices_samples == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        sc_lv<16> *mem_indices_samples = new sc_lv<16>[10];
        int i = 0;
        while (AESL_token != "[[/transaction]]") {
            sc_lv<1024> AESL_tempval =  AESL_token.c_str();
            mem_indices_samples[i] = AESL_tempval;
            i++;
            AESL_fh.read(AUTOTB_TVIN_indices_samples, AESL_token);
        }
        AESL_inst_indices_samples->set_pool(mem_indices_samples, 10);
        delete [] mem_indices_samples;
        AESL_fh.read(AUTOTB_TVIN_indices_samples, AESL_token);
        
        wait();
        
        wait(10, SC_PS);
    }
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_tv_in_indices_stride()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_indices_stride, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_indices_stride , exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_indices_stride, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_indices_stride, AESL_token);
        
        wait();
        wait(20, SC_PS);
        while (AESL_transaction_ready_indices_stride == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        sc_lv<8> *mem_indices_stride = new sc_lv<8>[10];
        int i = 0;
        while (AESL_token != "[[/transaction]]") {
            sc_lv<1024> AESL_tempval =  AESL_token.c_str();
            mem_indices_stride[i] = AESL_tempval;
            i++;
            AESL_fh.read(AUTOTB_TVIN_indices_stride, AESL_token);
        }
        AESL_inst_indices_stride->set_pool(mem_indices_stride, 10);
        delete [] mem_indices_stride;
        AESL_fh.read(AUTOTB_TVIN_indices_stride, AESL_token);
        
        wait();
        
        wait(10, SC_PS);
    }
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_tv_in_begin_index()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_begin_index, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_begin_index, exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_begin_index, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_begin_index, AESL_token);
        
        wait();
        wait(20, SC_PS);
        while (AESL_transaction_ready_begin_index == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        while (AESL_token != "[[/transaction]]") {
            sc_lv<1024> AESL_tempval =  AESL_token.c_str();
            begin_index.write(AESL_tempval);
            AESL_fh.read(AUTOTB_TVIN_begin_index, AESL_token);
        }
        AESL_fh.read(AUTOTB_TVIN_begin_index, AESL_token);
        
        
        wait(10, SC_PS);
    }
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_tv_in_begin_sample()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_begin_sample, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_begin_sample, exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_begin_sample, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_begin_sample, AESL_token);
        
        wait();
        wait(20, SC_PS);
        while (AESL_transaction_ready_begin_sample == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        while (AESL_token != "[[/transaction]]") {
            sc_lv<1024> AESL_tempval =  AESL_token.c_str();
            begin_sample.write(AESL_tempval);
            AESL_fh.read(AUTOTB_TVIN_begin_sample, AESL_token);
        }
        AESL_fh.read(AUTOTB_TVIN_begin_sample, AESL_token);
        
        
        wait(10, SC_PS);
    }
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_tv_in_end_index()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_end_index, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_end_index, exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_end_index, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_end_index, AESL_token);
        
        wait();
        wait(20, SC_PS);
        while (AESL_transaction_ready_end_index == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        while (AESL_token != "[[/transaction]]") {
            sc_lv<1024> AESL_tempval =  AESL_token.c_str();
            end_index.write(AESL_tempval);
            AESL_fh.read(AUTOTB_TVIN_end_index, AESL_token);
        }
        AESL_fh.read(AUTOTB_TVIN_end_index, AESL_token);
        
        
        wait(10, SC_PS);
    }
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_tv_in_end_sample()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_end_sample, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_end_sample, exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_end_sample, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_end_sample, AESL_token);
        
        wait();
        wait(20, SC_PS);
        while (AESL_transaction_ready_end_sample == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        while (AESL_token != "[[/transaction]]") {
            sc_lv<1024> AESL_tempval =  AESL_token.c_str();
            end_sample.write(AESL_tempval);
            AESL_fh.read(AUTOTB_TVIN_end_sample, AESL_token);
        }
        AESL_fh.read(AUTOTB_TVIN_end_sample, AESL_token);
        
        
        wait(10, SC_PS);
    }
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_tv_in_stop_on_first()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_stop_on_first, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_stop_on_first, exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_stop_on_first, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_stop_on_first, AESL_token);
        
        wait();
        wait(20, SC_PS);
        while (AESL_transaction_ready_stop_on_first == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        while (AESL_token != "[[/transaction]]") {
            sc_lv<1024> AESL_tempval =  AESL_token.c_str();
            stop_on_first.write(AESL_tempval);
            AESL_fh.read(AUTOTB_TVIN_stop_on_first, AESL_token);
        }
        AESL_fh.read(AUTOTB_TVIN_stop_on_first, AESL_token);
        
        
        wait(10, SC_PS);
    }
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_tv_in_accept()
{
    string AESL_transIdx;
    unsigned AESL_i = 0;
    wait();
    wait(20, SC_PS);
    string AESL_token;
    
    AESL_fh.read(AUTOTB_TVIN_accept, AESL_token);
    while (AESL_token != "[[[/runtime]]]") {
        if (AESL_token != "[[transaction]]") {
            cerr << "illegal tv format of AUTOTB_TVIN_accept, exit!\n";
            AESL_mErrNo++;
            sc_stop();
            return;
        }
        AESL_fh.read(AUTOTB_TVIN_accept, AESL_transIdx);
        AESL_fh.read(AUTOTB_TVIN_accept, AESL_token);
        
        wait();
        wait(20, SC_PS);
        while (AESL_transaction_ready_accept == SC_LOGIC_0) {
            wait();
            wait(20, SC_PS);
        }
        while (AESL_token != "[[/transaction]]") {
            sc_lv<1024> AESL_tempval =  AESL_token.c_str();
            accept.write(AESL_tempval);
            AESL_fh.read(AUTOTB_TVIN_accept, AESL_token);
        }
        AESL_fh.read(AUTOTB_TVIN_accept, AESL_token);
        
        
        wait(10, SC_PS);
    }
    while (1) wait();
}

void AUTOTB_TOP::AESL_proc_tv_out_ap_return()
{
    wait();

    unsigned AESL_transIdx = 0;
    unsigned AESL_i;
    stringstream AESL_str;

    while (AESL_transIdx < AUTOTB_TRANSACTION_NUM) {
        AESL_str.str("");
        AESL_str <<"[[transaction]]" ;
        AESL_str << " " << AESL_transIdx << endl;
        AESL_fh.write(AUTOTB_TVOUT_ap_return_out_wrapc, AESL_str.str());
        AESL_transIdx ++;
        wait();

        unsigned AESL_latency = 0;
        bool AESL_timeout = false;
        while (AESL_done.read() != SC_LOGIC_1) {
            AESL_latency++;
            wait();
        }


        sc_lv<32> AESL_expected;
        if (!AESL_timeout) {
            if (1) {
                char AESL_szName[1024];
                sprintf(AESL_szName, "ap_return");;
                unsigned AESL_wlen =  strlen(AESL_szName);
                string AESL_sphd =  string(AESL_wlen, ' ');
                string argValStr = "X";
                int flag_ap_return_is_01 = 0 ;
                int tmp_num;
                sc_lv<32> tmp_ap_return = ap_return.read(); 
                for (tmp_num = 0 ; tmp_num < 32 ; tmp_num++) {
                    if (tmp_ap_return[tmp_num].is_01()) {
                        flag_ap_return_is_01 = 1;
                        break;
                    }
                }
                if(flag_ap_return_is_01 == 1) {
                    for (tmp_num = 0 ; tmp_num < 32 ; tmp_num++) {
                        if (!tmp_ap_return[tmp_num].is_01()) {
                            tmp_ap_return[tmp_num] = 0;
                        }
                    }
                    argValStr = tmp_ap_return.to_string(SC_HEX);
                }
                if (argValStr == "X") {
                    AESL_str.str("");
                    AESL_str << ap_return.read() << endl;
                    AESL_fh.write(AUTOTB_TVOUT_ap_return_out_wrapc, AESL_str.str());
                } else {
                    AESL_str.str("");
                    AESL_str << argValStr << endl;
                    AESL_fh.write(AUTOTB_TVOUT_ap_return_out_wrapc, AESL_str.str());
                }
            }
            else if (AESL_BUFF_ap_return.read().is_01()) {
                char AESL_szName[1024];
                sprintf(AESL_szName, "ap_return");;
                unsigned AESL_wlen =  strlen(AESL_szName);
                string AESL_sphd =  string(AESL_wlen, ' ');
                string argValStr = "X";
                int flag_AESL_BUFF_ap_return_is_01 = 0 ;
                int tmp_num;
                sc_lv<32> tmp_AESL_BUFF_ap_return = AESL_BUFF_ap_return.read(); 
                for (tmp_num = 0 ; tmp_num < 32 ; tmp_num++) {
                    if (tmp_AESL_BUFF_ap_return[tmp_num].is_01()) {
                        flag_AESL_BUFF_ap_return_is_01 = 1;
                        break;
                    }
                }
                if(flag_AESL_BUFF_ap_return_is_01 == 1) {
                    for (tmp_num = 0 ; tmp_num < 32 ; tmp_num++) {
                        if (!tmp_AESL_BUFF_ap_return[tmp_num].is_01()) {
                            tmp_AESL_BUFF_ap_return[tmp_num] = 0;
                        }
                    }
                    argValStr = tmp_AESL_BUFF_ap_return.to_string(SC_HEX);
                }
                if (argValStr == "X") {
                    AESL_str.str("");
                    AESL_str << AESL_BUFF_ap_return.read() << endl;
                    AESL_fh.write(AUTOTB_TVOUT_ap_return_out_wrapc, AESL_str.str());
                } else {
                    AESL_str.str("");
                    AESL_str << argValStr << endl;
                    AESL_fh.write(AUTOTB_TVOUT_ap_return_out_wrapc, AESL_str.str());
                }
            }
        }

            AESL_str.str("");
            AESL_str << "[[/transaction]]" << endl;
            AESL_fh.write(AUTOTB_TVOUT_ap_return_out_wrapc, AESL_str.str());
    }


    AESL_mFinishTvOut_ap_return = true;

    while (1) wait();
}


#if defined(AESL_APATB_EXPORT)
#endif

#if !defined(AESL_APATB_EXPORT)
int sc_main(int ap_argc, char* ap_argv[])
{
    sc_clock clk("clk", 2.000000,SC_NS,0.5,0,SC_NS,false);
    AUTOTB_TOP AUTOTB_TOP_INST("top");

    AUTOTB_TOP_INST.AESL_clock(clk); 

    sc_report_handler::set_actions( SC_ID_LOGIC_X_TO_BOOL_, SC_LOG);
    sc_report_handler::set_actions( SC_ID_VECTOR_CONTAINS_LOGIC_VALUE_, SC_LOG);
    sc_report_handler::set_actions( SC_ID_MORE_THAN_ONE_SIGNAL_DRIVER_, SC_DISPLAY | SC_ABORT);

    sc_report_handler::set_actions("/IEEE_Std_1666/deprecated", SC_DO_NOTHING);
    try {
        sc_start();
    } catch (const sc_report& ex) {
        AUTOTB_TOP_INST.AESL_mErrNo++;
        cout << "\n" << ex.what() << endl;
	  } catch (...) {
        AUTOTB_TOP_INST.AESL_mErrNo++;
	      cout << "\nSystemC unknown internal error.\n";
    }

    return ((AUTOTB_TOP_INST.AESL_mErrNo != 0)? 1: 0);
}
#endif


#ifdef AESL_APATB_EXPORT
SC_MODULE_EXPORT(apatb_nfa_accept_samples_generic_hw_top);
#endif

