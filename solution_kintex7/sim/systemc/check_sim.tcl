# ==============================================================
# File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
# Version: 2013.4
# Copyright (C) 2013 Xilinx Inc. All rights reserved.
# 
# ==============================================================

proc sc_sim_check { ret err logfile } {
    set errfile "err.log"
    if {[file exists $errfile] && [file size $errfile] != 0} {
        set fl [open $errfile r]
        while {[gets $fl line] >= 0} {
            if {[string first "AESL_mErrNo = " $line] == 0} {
                set mismatch_num [string range $line [string length "AESL_mErrNo = "] end]
                if {$mismatch_num != 0} {
                    puts "@E SystemC simulation FAILED with ${mismatch_num} mismatches detected."
                    break
                }
            }
        }
    }
    if {$ret || $err != ""} {
        if { [lindex $::errorCode 0] eq "CHILDSTATUS"} {
            set status [lindex $::errorCode 2]
            if {$status != ""} {
                puts "@E Simulation failed: Function \'main\' returns nonzero value \'$status\'."
            } else {
                puts "@E Simulation failed."
            }
        } else {
            puts "@E Simulation failed."
        }
    }
    if {[file exists $logfile]} {
        set cmdret [catch {eval exec "grep \"Error:\" $logfile"} err]
        file delete -force $logfile
        if {$cmdret == 0} {
            puts "@E Simulation failed."
        }
    }
}
proc check_tvin_file {} {
    set rtlfilelist {
         "c.nfa_accept_samples_generic_hw.autotvin_nfa_initials_buckets.dat"
         "c.nfa_accept_samples_generic_hw.autotvin_nfa_finals_buckets.dat"
         "c.nfa_accept_samples_generic_hw.autotvin_nfa_forward_buckets.dat"
         "c.nfa_accept_samples_generic_hw.autotvin_nfa_symbols.dat"
         "c.nfa_accept_samples_generic_hw.autotvin_sample_buffer.dat"
         "c.nfa_accept_samples_generic_hw.autotvin_sample_buffer_length.dat"
         "c.nfa_accept_samples_generic_hw.autotvin_sample_length.dat"
         "c.nfa_accept_samples_generic_hw.autotvin_indices_begin.dat"
         "c.nfa_accept_samples_generic_hw.autotvin_indices_samples.dat"
         "c.nfa_accept_samples_generic_hw.autotvin_indices_stride.dat"
         "c.nfa_accept_samples_generic_hw.autotvin_begin_index.dat"
         "c.nfa_accept_samples_generic_hw.autotvin_begin_sample.dat"
         "c.nfa_accept_samples_generic_hw.autotvin_end_index.dat"
         "c.nfa_accept_samples_generic_hw.autotvin_end_sample.dat"
         "c.nfa_accept_samples_generic_hw.autotvin_stop_on_first.dat"
         "c.nfa_accept_samples_generic_hw.autotvin_accept.dat"
         "c.nfa_accept_samples_generic_hw.autotvout_ap_return.dat"
    }
    foreach rtlfile $rtlfilelist {
        if {[file isfile $rtlfile]} {
        } else {
            puts "Can't find file $rtlfile."
            return 1
        }
        set ret [catch {eval exec "grep /runtime $rtlfile"} err]
        if { $ret } {
            puts "$rtlfile file format is incorrect, please rerun cosim."
            return 1
        }
    }
    return 0
}

proc check_tvout_file {} {
    set rtlfilelist {
         "rtl.nfa_accept_samples_generic_hw.autotvout_ap_return.dat"
    }
    foreach rtlfile $rtlfilelist {
        if {[file isfile $rtlfile]} {
        } else {
            puts "Can't find file $rtlfile."
            return 1
        }
        set ret [catch {eval exec "grep /runtime $rtlfile"} err]
        if { $ret } {
            puts "$rtlfile file format is incorrect, please rerun cosim."
            return 1
        }
    }
    return 0
}
