-- ==============================================================
-- File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
-- Version: 2013.4
-- Copyright (C) 2013 Xilinx Inc. All rights reserved.
-- 
-- ==============================================================

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_unsigned.all;
use IEEE.numeric_std.all;
use ieee.std_logic_textio.all;
use std.textio.all;

library work;
use work.all;

entity apatb_nfa_accept_samples_generic_hw_top is
  generic (
	    AUTOTB_CLOCK_PERIOD	:   TIME := 2.000000 ns;
       AUTOTB_TVIN_nfa_initials_buckets : STRING := "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_nfa_initials_buckets.dat";
       AUTOTB_TVIN_nfa_finals_buckets : STRING := "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_nfa_finals_buckets.dat";
       AUTOTB_TVIN_nfa_forward_buckets : STRING := "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_nfa_forward_buckets.dat";
       AUTOTB_TVIN_nfa_symbols : STRING := "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_nfa_symbols.dat";
       AUTOTB_TVIN_sample_buffer : STRING := "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_sample_buffer.dat";
       AUTOTB_TVIN_sample_buffer_length : STRING := "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_sample_buffer_length.dat";
       AUTOTB_TVIN_sample_length : STRING := "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_sample_length.dat";
       AUTOTB_TVIN_indices_begin : STRING := "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_indices_begin.dat";
       AUTOTB_TVIN_indices_samples : STRING := "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_indices_samples.dat";
       AUTOTB_TVIN_indices_stride : STRING := "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_indices_stride.dat";
       AUTOTB_TVIN_begin_index : STRING := "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_begin_index.dat";
       AUTOTB_TVIN_begin_sample : STRING := "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_begin_sample.dat";
       AUTOTB_TVIN_end_index : STRING := "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_end_index.dat";
       AUTOTB_TVIN_end_sample : STRING := "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_end_sample.dat";
       AUTOTB_TVIN_stop_on_first : STRING := "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_stop_on_first.dat";
       AUTOTB_TVIN_accept : STRING := "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvin_accept.dat";
       AUTOTB_TVIN_nfa_initials_buckets_out_wrapc : STRING := "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_nfa_initials_buckets.dat";
       AUTOTB_TVIN_nfa_finals_buckets_out_wrapc : STRING := "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_nfa_finals_buckets.dat";
       AUTOTB_TVIN_nfa_forward_buckets_out_wrapc : STRING := "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_nfa_forward_buckets.dat";
       AUTOTB_TVIN_nfa_symbols_out_wrapc : STRING := "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_nfa_symbols.dat";
       AUTOTB_TVIN_sample_buffer_out_wrapc : STRING := "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_sample_buffer.dat";
       AUTOTB_TVIN_sample_buffer_length_out_wrapc : STRING := "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_sample_buffer_length.dat";
       AUTOTB_TVIN_sample_length_out_wrapc : STRING := "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_sample_length.dat";
       AUTOTB_TVIN_indices_begin_out_wrapc : STRING := "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_indices_begin.dat";
       AUTOTB_TVIN_indices_samples_out_wrapc : STRING := "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_indices_samples.dat";
       AUTOTB_TVIN_indices_stride_out_wrapc : STRING := "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_indices_stride.dat";
       AUTOTB_TVIN_begin_index_out_wrapc : STRING := "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_begin_index.dat";
       AUTOTB_TVIN_begin_sample_out_wrapc : STRING := "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_begin_sample.dat";
       AUTOTB_TVIN_end_index_out_wrapc : STRING := "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_end_index.dat";
       AUTOTB_TVIN_end_sample_out_wrapc : STRING := "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_end_sample.dat";
       AUTOTB_TVIN_stop_on_first_out_wrapc : STRING := "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_stop_on_first.dat";
       AUTOTB_TVIN_accept_out_wrapc : STRING := "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvin_accept.dat";
       AUTOTB_TVOUT_ap_return : STRING := "../tv/cdatafile/c.nfa_accept_samples_generic_hw.autotvout_ap_return.dat";
       AUTOTB_TVOUT_ap_return_out_wrapc : STRING := "../tv/rtldatafile/rtl.nfa_accept_samples_generic_hw.autotvout_ap_return.dat";
      AUTOTB_LAT_RESULT_FILE    : STRING  := "nfa_accept_samples_generic_hw.result.lat.rb";
      AUTOTB_PER_RESULT_TRANS_FILE    : STRING  := "nfa_accept_samples_generic_hw.performance.result.transaction.xml";
      LENGTH_nfa_initials_buckets     : INTEGER := 2;
      LENGTH_nfa_finals_buckets     : INTEGER := 2;
      LENGTH_nfa_forward_buckets     : INTEGER := 10;
      LENGTH_nfa_symbols     : INTEGER := 1;
      LENGTH_sample_buffer     : INTEGER := 10;
      LENGTH_sample_buffer_length     : INTEGER := 1;
      LENGTH_sample_length     : INTEGER := 1;
      LENGTH_indices_begin     : INTEGER := 10;
      LENGTH_indices_samples     : INTEGER := 10;
      LENGTH_indices_stride     : INTEGER := 10;
      LENGTH_begin_index     : INTEGER := 1;
      LENGTH_begin_sample     : INTEGER := 1;
      LENGTH_end_index     : INTEGER := 1;
      LENGTH_end_sample     : INTEGER := 1;
      LENGTH_stop_on_first     : INTEGER := 1;
      LENGTH_accept     : INTEGER := 1;
      LENGTH_ap_return     : INTEGER := 1;
	    AUTOTB_TRANSACTION_NUM    : INTEGER := 4
);

end apatb_nfa_accept_samples_generic_hw_top;

architecture behav of apatb_nfa_accept_samples_generic_hw_top is 
  signal AESL_clock	:   STD_LOGIC := '0';
  signal rst  :   STD_LOGIC;
  signal start    :   STD_LOGIC := '0';
  signal ce       :   STD_LOGIC;
  signal continue :   STD_LOGIC := '0';
  signal AESL_reset :   STD_LOGIC := '0';
  signal AESL_start :   STD_LOGIC := '0';
  signal AESL_ce :   STD_LOGIC := '0';
  signal AESL_continue :   STD_LOGIC := '0';
  signal AESL_ready :   STD_LOGIC := '0';
  signal AESL_idle :   STD_LOGIC := '0';
  signal AESL_done :   STD_LOGIC := '0';
  signal AESL_done_delay :   STD_LOGIC := '0';
  signal AESL_done_delay2 :   STD_LOGIC := '0';
  signal AESL_ready_delay :   STD_LOGIC := '0';
  signal ready :   STD_LOGIC := '0';
  signal ready_wire :   STD_LOGIC := '0';

  signal ap_clk :  STD_LOGIC;
  signal ap_rst :  STD_LOGIC;
  signal ap_start :  STD_LOGIC;
  signal ap_done :  STD_LOGIC;
  signal ap_idle :  STD_LOGIC;
  signal ap_ready :  STD_LOGIC;
  signal nfa_initials_buckets_req_din :  STD_LOGIC;
  signal nfa_initials_buckets_req_full_n :  STD_LOGIC;
  signal nfa_initials_buckets_req_write :  STD_LOGIC;
  signal nfa_initials_buckets_rsp_empty_n :  STD_LOGIC;
  signal nfa_initials_buckets_rsp_read :  STD_LOGIC;
  signal nfa_initials_buckets_address :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal nfa_initials_buckets_datain :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal nfa_initials_buckets_dataout :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal nfa_initials_buckets_size :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal nfa_finals_buckets_req_din :  STD_LOGIC;
  signal nfa_finals_buckets_req_full_n :  STD_LOGIC;
  signal nfa_finals_buckets_req_write :  STD_LOGIC;
  signal nfa_finals_buckets_rsp_empty_n :  STD_LOGIC;
  signal nfa_finals_buckets_rsp_read :  STD_LOGIC;
  signal nfa_finals_buckets_address :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal nfa_finals_buckets_datain :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal nfa_finals_buckets_dataout :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal nfa_finals_buckets_size :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal nfa_forward_buckets_req_din :  STD_LOGIC;
  signal nfa_forward_buckets_req_full_n :  STD_LOGIC;
  signal nfa_forward_buckets_req_write :  STD_LOGIC;
  signal nfa_forward_buckets_rsp_empty_n :  STD_LOGIC;
  signal nfa_forward_buckets_rsp_read :  STD_LOGIC;
  signal nfa_forward_buckets_address :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal nfa_forward_buckets_datain :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal nfa_forward_buckets_dataout :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal nfa_forward_buckets_size :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal nfa_symbols :  STD_LOGIC_VECTOR (7 DOWNTO 0);
  signal sample_buffer_req_din :  STD_LOGIC;
  signal sample_buffer_req_full_n :  STD_LOGIC;
  signal sample_buffer_req_write :  STD_LOGIC;
  signal sample_buffer_rsp_empty_n :  STD_LOGIC;
  signal sample_buffer_rsp_read :  STD_LOGIC;
  signal sample_buffer_address :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal sample_buffer_datain :  STD_LOGIC_VECTOR (7 DOWNTO 0);
  signal sample_buffer_dataout :  STD_LOGIC_VECTOR (7 DOWNTO 0);
  signal sample_buffer_size :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal sample_buffer_length :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal sample_length :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal indices_begin_req_din :  STD_LOGIC;
  signal indices_begin_req_full_n :  STD_LOGIC;
  signal indices_begin_req_write :  STD_LOGIC;
  signal indices_begin_rsp_empty_n :  STD_LOGIC;
  signal indices_begin_rsp_read :  STD_LOGIC;
  signal indices_begin_address :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal indices_begin_datain :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal indices_begin_dataout :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal indices_begin_size :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal indices_samples_req_din :  STD_LOGIC;
  signal indices_samples_req_full_n :  STD_LOGIC;
  signal indices_samples_req_write :  STD_LOGIC;
  signal indices_samples_rsp_empty_n :  STD_LOGIC;
  signal indices_samples_rsp_read :  STD_LOGIC;
  signal indices_samples_address :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal indices_samples_datain :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal indices_samples_dataout :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal indices_samples_size :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal indices_stride_req_din :  STD_LOGIC;
  signal indices_stride_req_full_n :  STD_LOGIC;
  signal indices_stride_req_write :  STD_LOGIC;
  signal indices_stride_rsp_empty_n :  STD_LOGIC;
  signal indices_stride_rsp_read :  STD_LOGIC;
  signal indices_stride_address :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal indices_stride_datain :  STD_LOGIC_VECTOR (7 DOWNTO 0);
  signal indices_stride_dataout :  STD_LOGIC_VECTOR (7 DOWNTO 0);
  signal indices_stride_size :  STD_LOGIC_VECTOR (31 DOWNTO 0);
  signal i_size :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal begin_index :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal begin_sample :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal end_index :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal end_sample :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal stop_on_first :  STD_LOGIC_VECTOR (0 DOWNTO 0);
  signal accept :  STD_LOGIC_VECTOR (0 DOWNTO 0);
  signal ap_return :  STD_LOGIC_VECTOR (31 DOWNTO 0);

  shared variable AESL_ready_cnt	:   INTEGER := 0;
  shared variable ready_cnt	:   INTEGER := 0;
  shared variable done_cnt	:   INTEGER := 0;
  signal ready_initial  :	STD_LOGIC;
  signal ready_initial_n	:   STD_LOGIC;
  signal ready_last_n   :	STD_LOGIC;
  signal ready_delay_last_n	:   STD_LOGIC;
  signal done_delay_last_n	:   STD_LOGIC;
  signal interface_done :	STD_LOGIC := '0';
  -- Subtype for random state number, to prevent confusing it with true integers
  -- Top of range should be (2**31)-1 but this literal calculation causes overflow on 32-bit machines
  subtype T_RANDINT is integer range 1 to integer'high;

  type latency_record is array(0 to AUTOTB_TRANSACTION_NUM + 1) of INTEGER;
  shared variable AESL_mLatCnterIn : latency_record;
  shared variable AESL_mLatCnterOut : latency_record;
  shared variable AESL_mLatCnterIn_addr : INTEGER;
  shared variable AESL_mLatCnterOut_addr : INTEGER;
  shared variable AESL_clk_counter : INTEGER;
component nfa_accept_samples_generic_hw is
port (
    ap_clk :  IN STD_LOGIC;
    ap_rst :  IN STD_LOGIC;
    ap_start :  IN STD_LOGIC;
    ap_done :  OUT STD_LOGIC;
    ap_idle :  OUT STD_LOGIC;
    ap_ready :  OUT STD_LOGIC;
    nfa_initials_buckets_req_din :  OUT STD_LOGIC;
    nfa_initials_buckets_req_full_n :  IN STD_LOGIC;
    nfa_initials_buckets_req_write :  OUT STD_LOGIC;
    nfa_initials_buckets_rsp_empty_n :  IN STD_LOGIC;
    nfa_initials_buckets_rsp_read :  OUT STD_LOGIC;
    nfa_initials_buckets_address :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
    nfa_initials_buckets_datain :  IN STD_LOGIC_VECTOR (31 DOWNTO 0);
    nfa_initials_buckets_dataout :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
    nfa_initials_buckets_size :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
    nfa_finals_buckets_req_din :  OUT STD_LOGIC;
    nfa_finals_buckets_req_full_n :  IN STD_LOGIC;
    nfa_finals_buckets_req_write :  OUT STD_LOGIC;
    nfa_finals_buckets_rsp_empty_n :  IN STD_LOGIC;
    nfa_finals_buckets_rsp_read :  OUT STD_LOGIC;
    nfa_finals_buckets_address :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
    nfa_finals_buckets_datain :  IN STD_LOGIC_VECTOR (31 DOWNTO 0);
    nfa_finals_buckets_dataout :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
    nfa_finals_buckets_size :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
    nfa_forward_buckets_req_din :  OUT STD_LOGIC;
    nfa_forward_buckets_req_full_n :  IN STD_LOGIC;
    nfa_forward_buckets_req_write :  OUT STD_LOGIC;
    nfa_forward_buckets_rsp_empty_n :  IN STD_LOGIC;
    nfa_forward_buckets_rsp_read :  OUT STD_LOGIC;
    nfa_forward_buckets_address :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
    nfa_forward_buckets_datain :  IN STD_LOGIC_VECTOR (31 DOWNTO 0);
    nfa_forward_buckets_dataout :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
    nfa_forward_buckets_size :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
    nfa_symbols :  IN STD_LOGIC_VECTOR (7 DOWNTO 0);
    sample_buffer_req_din :  OUT STD_LOGIC;
    sample_buffer_req_full_n :  IN STD_LOGIC;
    sample_buffer_req_write :  OUT STD_LOGIC;
    sample_buffer_rsp_empty_n :  IN STD_LOGIC;
    sample_buffer_rsp_read :  OUT STD_LOGIC;
    sample_buffer_address :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
    sample_buffer_datain :  IN STD_LOGIC_VECTOR (7 DOWNTO 0);
    sample_buffer_dataout :  OUT STD_LOGIC_VECTOR (7 DOWNTO 0);
    sample_buffer_size :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
    sample_buffer_length :  IN STD_LOGIC_VECTOR (31 DOWNTO 0);
    sample_length :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    indices_begin_req_din :  OUT STD_LOGIC;
    indices_begin_req_full_n :  IN STD_LOGIC;
    indices_begin_req_write :  OUT STD_LOGIC;
    indices_begin_rsp_empty_n :  IN STD_LOGIC;
    indices_begin_rsp_read :  OUT STD_LOGIC;
    indices_begin_address :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
    indices_begin_datain :  IN STD_LOGIC_VECTOR (31 DOWNTO 0);
    indices_begin_dataout :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
    indices_begin_size :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
    indices_samples_req_din :  OUT STD_LOGIC;
    indices_samples_req_full_n :  IN STD_LOGIC;
    indices_samples_req_write :  OUT STD_LOGIC;
    indices_samples_rsp_empty_n :  IN STD_LOGIC;
    indices_samples_rsp_read :  OUT STD_LOGIC;
    indices_samples_address :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
    indices_samples_datain :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    indices_samples_dataout :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    indices_samples_size :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
    indices_stride_req_din :  OUT STD_LOGIC;
    indices_stride_req_full_n :  IN STD_LOGIC;
    indices_stride_req_write :  OUT STD_LOGIC;
    indices_stride_rsp_empty_n :  IN STD_LOGIC;
    indices_stride_rsp_read :  OUT STD_LOGIC;
    indices_stride_address :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
    indices_stride_datain :  IN STD_LOGIC_VECTOR (7 DOWNTO 0);
    indices_stride_dataout :  OUT STD_LOGIC_VECTOR (7 DOWNTO 0);
    indices_stride_size :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
    i_size :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    begin_index :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    begin_sample :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    end_index :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    end_sample :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    stop_on_first :  IN STD_LOGIC_VECTOR (0 DOWNTO 0);
    accept :  IN STD_LOGIC_VECTOR (0 DOWNTO 0);
    ap_return :  OUT STD_LOGIC_VECTOR (31 DOWNTO 0));
end component;

signal bus_nfa_initials_buckets_req_RW      : STD_LOGIC;
signal bus_nfa_initials_buckets_req_full_n  : STD_LOGIC;
signal reg_bus_nfa_initials_buckets_req_full_n  : STD_LOGIC;
signal bus_nfa_initials_buckets_req_RW_en   : STD_LOGIC;
signal bus_nfa_initials_buckets_rsp_empty_n : STD_LOGIC;
signal reg_bus_nfa_initials_buckets_rsp_empty_n : STD_LOGIC;
signal bus_nfa_initials_buckets_rsp_read    : STD_LOGIC;
signal bus_nfa_initials_buckets_address     : STD_LOGIC_VECTOR(31 downto 0);
signal bus_nfa_initials_buckets_din         : STD_LOGIC_VECTOR(31 downto 0);
signal bus_nfa_initials_buckets_dout        : STD_LOGIC_VECTOR(31 downto 0);
signal bus_nfa_initials_buckets_size        : STD_LOGIC_VECTOR(31 downto 0);
signal bus_nfa_initials_buckets_ready       : STD_LOGIC;
signal bus_nfa_initials_buckets_done        : STD_LOGIC;

component AESL_autobus_nfa_initials_buckets is
  port(
    clk	            :   IN  STD_LOGIC;
    rst	            :   IN  STD_LOGIC;
    bus_req_RW	    :   IN  STD_LOGIC;
    bus_req_full_n    :   OUT STD_LOGIC;
    bus_req_RW_en     :   IN  STD_LOGIC;
    bus_rsp_empty_n   :   OUT STD_LOGIC;
    bus_rsp_read      :   IN  STD_LOGIC;
    bus_address       :   IN  STD_LOGIC_VECTOR;
    bus_din	        :   IN  STD_LOGIC_VECTOR;
    bus_dout	        :   OUT STD_LOGIC_VECTOR;
    bus_size	        :   IN  STD_LOGIC_VECTOR;
    ready	            :   IN  STD_LOGIC;
    done	            :   IN  STD_LOGIC
  );
end component;

signal bus_nfa_finals_buckets_req_RW      : STD_LOGIC;
signal bus_nfa_finals_buckets_req_full_n  : STD_LOGIC;
signal reg_bus_nfa_finals_buckets_req_full_n  : STD_LOGIC;
signal bus_nfa_finals_buckets_req_RW_en   : STD_LOGIC;
signal bus_nfa_finals_buckets_rsp_empty_n : STD_LOGIC;
signal reg_bus_nfa_finals_buckets_rsp_empty_n : STD_LOGIC;
signal bus_nfa_finals_buckets_rsp_read    : STD_LOGIC;
signal bus_nfa_finals_buckets_address     : STD_LOGIC_VECTOR(31 downto 0);
signal bus_nfa_finals_buckets_din         : STD_LOGIC_VECTOR(31 downto 0);
signal bus_nfa_finals_buckets_dout        : STD_LOGIC_VECTOR(31 downto 0);
signal bus_nfa_finals_buckets_size        : STD_LOGIC_VECTOR(31 downto 0);
signal bus_nfa_finals_buckets_ready       : STD_LOGIC;
signal bus_nfa_finals_buckets_done        : STD_LOGIC;

component AESL_autobus_nfa_finals_buckets is
  port(
    clk	            :   IN  STD_LOGIC;
    rst	            :   IN  STD_LOGIC;
    bus_req_RW	    :   IN  STD_LOGIC;
    bus_req_full_n    :   OUT STD_LOGIC;
    bus_req_RW_en     :   IN  STD_LOGIC;
    bus_rsp_empty_n   :   OUT STD_LOGIC;
    bus_rsp_read      :   IN  STD_LOGIC;
    bus_address       :   IN  STD_LOGIC_VECTOR;
    bus_din	        :   IN  STD_LOGIC_VECTOR;
    bus_dout	        :   OUT STD_LOGIC_VECTOR;
    bus_size	        :   IN  STD_LOGIC_VECTOR;
    ready	            :   IN  STD_LOGIC;
    done	            :   IN  STD_LOGIC
  );
end component;

signal bus_nfa_forward_buckets_req_RW      : STD_LOGIC;
signal bus_nfa_forward_buckets_req_full_n  : STD_LOGIC;
signal reg_bus_nfa_forward_buckets_req_full_n  : STD_LOGIC;
signal bus_nfa_forward_buckets_req_RW_en   : STD_LOGIC;
signal bus_nfa_forward_buckets_rsp_empty_n : STD_LOGIC;
signal reg_bus_nfa_forward_buckets_rsp_empty_n : STD_LOGIC;
signal bus_nfa_forward_buckets_rsp_read    : STD_LOGIC;
signal bus_nfa_forward_buckets_address     : STD_LOGIC_VECTOR(31 downto 0);
signal bus_nfa_forward_buckets_din         : STD_LOGIC_VECTOR(31 downto 0);
signal bus_nfa_forward_buckets_dout        : STD_LOGIC_VECTOR(31 downto 0);
signal bus_nfa_forward_buckets_size        : STD_LOGIC_VECTOR(31 downto 0);
signal bus_nfa_forward_buckets_ready       : STD_LOGIC;
signal bus_nfa_forward_buckets_done        : STD_LOGIC;

component AESL_autobus_nfa_forward_buckets is
  port(
    clk	            :   IN  STD_LOGIC;
    rst	            :   IN  STD_LOGIC;
    bus_req_RW	    :   IN  STD_LOGIC;
    bus_req_full_n    :   OUT STD_LOGIC;
    bus_req_RW_en     :   IN  STD_LOGIC;
    bus_rsp_empty_n   :   OUT STD_LOGIC;
    bus_rsp_read      :   IN  STD_LOGIC;
    bus_address       :   IN  STD_LOGIC_VECTOR;
    bus_din	        :   IN  STD_LOGIC_VECTOR;
    bus_dout	        :   OUT STD_LOGIC_VECTOR;
    bus_size	        :   IN  STD_LOGIC_VECTOR;
    ready	            :   IN  STD_LOGIC;
    done	            :   IN  STD_LOGIC
  );
end component;

signal arraynfa_backward_buckets_ce0, arraynfa_backward_buckets_ce1 : STD_LOGIC;
signal arraynfa_backward_buckets_we0, arraynfa_backward_buckets_we1 : STD_LOGIC;
signal arraynfa_backward_buckets_address0, arraynfa_backward_buckets_address1 : STD_LOGIC_VECTOR(14 downto 0);
signal arraynfa_backward_buckets_din0, arraynfa_backward_buckets_din1 : STD_LOGIC_VECTOR(31 downto 0);
signal arraynfa_backward_buckets_dout0, arraynfa_backward_buckets_dout1 :  STD_LOGIC_VECTOR(31 downto 0);
signal arraynfa_backward_buckets_ready : STD_LOGIC;
signal arraynfa_backward_buckets_done : STD_LOGIC;

component AESL_automem_nfa_backward_buckets is
  port(
    clk        :  IN  STD_LOGIC;
    rst        :  IN  STD_LOGIC;
    ce0        :  IN  STD_LOGIC;
    we0        :  IN  STD_LOGIC;
    address0   :  IN  STD_LOGIC_VECTOR;
    din0       :  IN  STD_LOGIC_VECTOR;
    dout0      :  OUT STD_LOGIC_VECTOR;
    ce1        :  IN  STD_LOGIC;
    we1        :  IN  STD_LOGIC;
    address1   :  IN  STD_LOGIC_VECTOR;
    din1       :  IN  STD_LOGIC_VECTOR;
    dout1      :  OUT STD_LOGIC_VECTOR;
    ready	     :  IN  STD_LOGIC;
    done	     :  IN  STD_LOGIC
  );
end component;

-- The signal of port nfa_symbols
shared variable AESL_REG_nfa_symbols : STD_LOGIC_VECTOR(7 downto 0) := (others => '0');
signal bus_sample_buffer_req_RW      : STD_LOGIC;
signal bus_sample_buffer_req_full_n  : STD_LOGIC;
signal reg_bus_sample_buffer_req_full_n  : STD_LOGIC;
signal bus_sample_buffer_req_RW_en   : STD_LOGIC;
signal bus_sample_buffer_rsp_empty_n : STD_LOGIC;
signal reg_bus_sample_buffer_rsp_empty_n : STD_LOGIC;
signal bus_sample_buffer_rsp_read    : STD_LOGIC;
signal bus_sample_buffer_address     : STD_LOGIC_VECTOR(31 downto 0);
signal bus_sample_buffer_din         : STD_LOGIC_VECTOR(7 downto 0);
signal bus_sample_buffer_dout        : STD_LOGIC_VECTOR(7 downto 0);
signal bus_sample_buffer_size        : STD_LOGIC_VECTOR(31 downto 0);
signal bus_sample_buffer_ready       : STD_LOGIC;
signal bus_sample_buffer_done        : STD_LOGIC;

component AESL_autobus_sample_buffer is
  port(
    clk	            :   IN  STD_LOGIC;
    rst	            :   IN  STD_LOGIC;
    bus_req_RW	    :   IN  STD_LOGIC;
    bus_req_full_n    :   OUT STD_LOGIC;
    bus_req_RW_en     :   IN  STD_LOGIC;
    bus_rsp_empty_n   :   OUT STD_LOGIC;
    bus_rsp_read      :   IN  STD_LOGIC;
    bus_address       :   IN  STD_LOGIC_VECTOR;
    bus_din	        :   IN  STD_LOGIC_VECTOR;
    bus_dout	        :   OUT STD_LOGIC_VECTOR;
    bus_size	        :   IN  STD_LOGIC_VECTOR;
    ready	            :   IN  STD_LOGIC;
    done	            :   IN  STD_LOGIC
  );
end component;

-- The signal of port sample_buffer_length
shared variable AESL_REG_sample_buffer_length : STD_LOGIC_VECTOR(31 downto 0) := (others => '0');
-- The signal of port sample_length
shared variable AESL_REG_sample_length : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
signal bus_indices_begin_req_RW      : STD_LOGIC;
signal bus_indices_begin_req_full_n  : STD_LOGIC;
signal reg_bus_indices_begin_req_full_n  : STD_LOGIC;
signal bus_indices_begin_req_RW_en   : STD_LOGIC;
signal bus_indices_begin_rsp_empty_n : STD_LOGIC;
signal reg_bus_indices_begin_rsp_empty_n : STD_LOGIC;
signal bus_indices_begin_rsp_read    : STD_LOGIC;
signal bus_indices_begin_address     : STD_LOGIC_VECTOR(31 downto 0);
signal bus_indices_begin_din         : STD_LOGIC_VECTOR(31 downto 0);
signal bus_indices_begin_dout        : STD_LOGIC_VECTOR(31 downto 0);
signal bus_indices_begin_size        : STD_LOGIC_VECTOR(31 downto 0);
signal bus_indices_begin_ready       : STD_LOGIC;
signal bus_indices_begin_done        : STD_LOGIC;

component AESL_autobus_indices_begin is
  port(
    clk	            :   IN  STD_LOGIC;
    rst	            :   IN  STD_LOGIC;
    bus_req_RW	    :   IN  STD_LOGIC;
    bus_req_full_n    :   OUT STD_LOGIC;
    bus_req_RW_en     :   IN  STD_LOGIC;
    bus_rsp_empty_n   :   OUT STD_LOGIC;
    bus_rsp_read      :   IN  STD_LOGIC;
    bus_address       :   IN  STD_LOGIC_VECTOR;
    bus_din	        :   IN  STD_LOGIC_VECTOR;
    bus_dout	        :   OUT STD_LOGIC_VECTOR;
    bus_size	        :   IN  STD_LOGIC_VECTOR;
    ready	            :   IN  STD_LOGIC;
    done	            :   IN  STD_LOGIC
  );
end component;

signal bus_indices_samples_req_RW      : STD_LOGIC;
signal bus_indices_samples_req_full_n  : STD_LOGIC;
signal reg_bus_indices_samples_req_full_n  : STD_LOGIC;
signal bus_indices_samples_req_RW_en   : STD_LOGIC;
signal bus_indices_samples_rsp_empty_n : STD_LOGIC;
signal reg_bus_indices_samples_rsp_empty_n : STD_LOGIC;
signal bus_indices_samples_rsp_read    : STD_LOGIC;
signal bus_indices_samples_address     : STD_LOGIC_VECTOR(31 downto 0);
signal bus_indices_samples_din         : STD_LOGIC_VECTOR(15 downto 0);
signal bus_indices_samples_dout        : STD_LOGIC_VECTOR(15 downto 0);
signal bus_indices_samples_size        : STD_LOGIC_VECTOR(31 downto 0);
signal bus_indices_samples_ready       : STD_LOGIC;
signal bus_indices_samples_done        : STD_LOGIC;

component AESL_autobus_indices_samples is
  port(
    clk	            :   IN  STD_LOGIC;
    rst	            :   IN  STD_LOGIC;
    bus_req_RW	    :   IN  STD_LOGIC;
    bus_req_full_n    :   OUT STD_LOGIC;
    bus_req_RW_en     :   IN  STD_LOGIC;
    bus_rsp_empty_n   :   OUT STD_LOGIC;
    bus_rsp_read      :   IN  STD_LOGIC;
    bus_address       :   IN  STD_LOGIC_VECTOR;
    bus_din	        :   IN  STD_LOGIC_VECTOR;
    bus_dout	        :   OUT STD_LOGIC_VECTOR;
    bus_size	        :   IN  STD_LOGIC_VECTOR;
    ready	            :   IN  STD_LOGIC;
    done	            :   IN  STD_LOGIC
  );
end component;

signal bus_indices_stride_req_RW      : STD_LOGIC;
signal bus_indices_stride_req_full_n  : STD_LOGIC;
signal reg_bus_indices_stride_req_full_n  : STD_LOGIC;
signal bus_indices_stride_req_RW_en   : STD_LOGIC;
signal bus_indices_stride_rsp_empty_n : STD_LOGIC;
signal reg_bus_indices_stride_rsp_empty_n : STD_LOGIC;
signal bus_indices_stride_rsp_read    : STD_LOGIC;
signal bus_indices_stride_address     : STD_LOGIC_VECTOR(31 downto 0);
signal bus_indices_stride_din         : STD_LOGIC_VECTOR(7 downto 0);
signal bus_indices_stride_dout        : STD_LOGIC_VECTOR(7 downto 0);
signal bus_indices_stride_size        : STD_LOGIC_VECTOR(31 downto 0);
signal bus_indices_stride_ready       : STD_LOGIC;
signal bus_indices_stride_done        : STD_LOGIC;

component AESL_autobus_indices_stride is
  port(
    clk	            :   IN  STD_LOGIC;
    rst	            :   IN  STD_LOGIC;
    bus_req_RW	    :   IN  STD_LOGIC;
    bus_req_full_n    :   OUT STD_LOGIC;
    bus_req_RW_en     :   IN  STD_LOGIC;
    bus_rsp_empty_n   :   OUT STD_LOGIC;
    bus_rsp_read      :   IN  STD_LOGIC;
    bus_address       :   IN  STD_LOGIC_VECTOR;
    bus_din	        :   IN  STD_LOGIC_VECTOR;
    bus_dout	        :   OUT STD_LOGIC_VECTOR;
    bus_size	        :   IN  STD_LOGIC_VECTOR;
    ready	            :   IN  STD_LOGIC;
    done	            :   IN  STD_LOGIC
  );
end component;

-- The signal of port i_size
shared variable AESL_REG_i_size : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port begin_index
shared variable AESL_REG_begin_index : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port begin_sample
shared variable AESL_REG_begin_sample : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port end_index
shared variable AESL_REG_end_index : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port end_sample
shared variable AESL_REG_end_sample : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port stop_on_first
shared variable AESL_REG_stop_on_first : STD_LOGIC_VECTOR(0 downto 0) := (others => '0');
-- The signal of port accept
shared variable AESL_REG_accept : STD_LOGIC_VECTOR(0 downto 0) := (others => '0');
      procedure esl_read_token (file textfile: TEXT; textline: inout LINE; token: out STRING; token_len: out INTEGER) is
          variable whitespace : CHARACTER;
          variable i : INTEGER;
          variable ok: BOOLEAN;
          variable buff: STRING(1 to token'length);
      begin
          ok := false;
          i := 1;
          loop_main: while not endfile(textfile) loop
              if textline = null or textline'length = 0 then
                  readline(textfile, textline);
              end if;
              loop_remove_whitespace: while textline'length > 0 loop
                  if textline(textline'left) = ' ' or
                      textline(textline'left) = HT or
                      textline(textline'left) = CR or
                      textline(textline'left) = LF then
                      read(textline, whitespace);
                  else
                      exit loop_remove_whitespace;
                  end if;
              end loop;
              loop_aesl_read_token: while textline'length > 0 and i <= buff'length loop
                  if textline(textline'left) = ' ' or
                     textline(textline'left) = HT or
                     textline(textline'left) = CR or
                     textline(textline'left) = LF then
                      exit loop_aesl_read_token;
                  else
                      read(textline, buff(i));
                      i := i + 1;
                  end if;
                  ok := true;
              end loop;
              if ok = true then
                  exit loop_main;
              end if;
          end loop;
          buff(i) := ' ';
          token := buff;
          token_len:= i-1;
      end procedure esl_read_token;

      procedure esl_read_token (file textfile: TEXT;
                                textline: inout LINE;
                                token: out STRING) is
          variable i : INTEGER;
      begin
          esl_read_token (textfile, textline, token, i);
      end procedure esl_read_token;

      function esl_str2lv_hex (RHS : STRING; data_width : INTEGER) return STD_LOGIC_VECTOR is
          variable	ret	:   STD_LOGIC_VECTOR(data_width - 1 downto 0);
          variable	idx	:   integer := 3;
      begin
          ret := (others => '0');
          if(RHS(1) /= '0' and (RHS(2) /= 'x' or RHS(2) /= 'X')) then
     	        report "Error! The format of hex number is not initialed by 0x";
          end if;
          while true loop
              if (data_width > 4) then
                  case RHS(idx)  is
                      when '0'    =>  ret := ret(data_width - 5 downto 0) & "0000";
     	                when '1'    =>  ret := ret(data_width - 5 downto 0) & "0001";
                      when '2'    =>  ret := ret(data_width - 5 downto 0) & "0010";
                      when '3'    =>  ret := ret(data_width - 5 downto 0) & "0011";
                      when '4'    =>  ret := ret(data_width - 5 downto 0) & "0100";
                      when '5'    =>  ret := ret(data_width - 5 downto 0) & "0101";
                      when '6'    =>  ret := ret(data_width - 5 downto 0) & "0110";
                      when '7'    =>  ret := ret(data_width - 5 downto 0) & "0111";
                      when '8'    =>  ret := ret(data_width - 5 downto 0) & "1000";
                      when '9'    =>  ret := ret(data_width - 5 downto 0) & "1001";
                      when 'a' | 'A'  =>  ret := ret(data_width - 5 downto 0) & "1010";
                      when 'b' | 'B'  =>  ret := ret(data_width - 5 downto 0) & "1011";
                      when 'c' | 'C'  =>  ret := ret(data_width - 5 downto 0) & "1100";
                      when 'd' | 'D'  =>  ret := ret(data_width - 5 downto 0) & "1101";
                      when 'e' | 'E'  =>  ret := ret(data_width - 5 downto 0) & "1110";
                      when 'f' | 'F'  =>  ret := ret(data_width - 5 downto 0) & "1111";
                      when ' '    =>  return ret;
                      when others    =>  report "Wrong hex char " & RHS(idx);	return ret;
                  end case;
              elsif (data_width = 4) then
                  case RHS(idx)  is
                      when '0'    =>  ret := "0000";
     	                when '1'    =>  ret := "0001";
                      when '2'    =>  ret := "0010";
                      when '3'    =>  ret := "0011";
                      when '4'    =>  ret := "0100";
                      when '5'    =>  ret := "0101";
                      when '6'    =>  ret := "0110";
                      when '7'    =>  ret := "0111";
                      when '8'    =>  ret := "1000";
                      when '9'    =>  ret := "1001";
                      when 'a' | 'A'  =>  ret := "1010";
                      when 'b' | 'B'  =>  ret := "1011";
                      when 'c' | 'C'  =>  ret := "1100";
                      when 'd' | 'D'  =>  ret := "1101";
                      when 'e' | 'E'  =>  ret := "1110";
                      when 'f' | 'F'  =>  ret := "1111";
                      when ' '    =>  return ret;
                      when others    =>  report "Wrong hex char " & RHS(idx);	return ret;
                  end case;
              elsif (data_width = 3) then
                  case RHS(idx)  is
                      when '0'    =>  ret := "000";
     	                when '1'    =>  ret := "001";
                      when '2'    =>  ret := "010";
                      when '3'    =>  ret := "011";
                      when '4'    =>  ret := "100";
                      when '5'    =>  ret := "101";
                      when '6'    =>  ret := "110";
                      when '7'    =>  ret := "111";
                      when ' '    =>  return ret;
                      when others    =>  report "Wrong hex char " & RHS(idx);	return ret;
                  end case;
              elsif (data_width = 2) then
                  case RHS(idx)  is
                      when '0'    =>  ret := "00";
     	                when '1'    =>  ret := "01";
                      when '2'    =>  ret := "10";
                      when '3'    =>  ret := "11";
                      when ' '    =>  return ret;
                      when others    =>  report "Wrong hex char " & RHS(idx);	return ret;
                  end case;
              elsif (data_width = 1) then
                  case RHS(idx)  is
                      when '0'    =>  ret := "0";
     	                when '1'    =>  ret := "1";
                      when ' '    =>  return ret;
                      when others    =>  report "Wrong hex char " & RHS(idx);	return ret;
                  end case;
              else
                  report string'("Wrong data_width.");
                  return ret;
              end if;
              idx := idx + 1;
          end loop;
          return ret;
      end function;

    function esl_str_dec2int (RHS : STRING) return INTEGER is
        variable	ret	:   integer;
        variable	idx	:   integer := 1;
    begin
        ret := 0;
        while true loop
            case RHS(idx)  is
                when '0'    =>  ret := ret * 10 + 0;
                when '1'    =>  ret := ret * 10 + 1;
                when '2'    =>  ret := ret * 10 + 2;
                when '3'    =>  ret := ret * 10 + 3;
                when '4'    =>  ret := ret * 10 + 4;
                when '5'    =>  ret := ret * 10 + 5;
                when '6'    =>  ret := ret * 10 + 6;
                when '7'    =>  ret := ret * 10 + 7;
                when '8'    =>  ret := ret * 10 + 8;
                when '9'    =>  ret := ret * 10 + 9;
                when ' '    =>  return ret;
                when others    =>  report "Wrong dec char " & RHS(idx);	return ret;
            end case;
            idx := idx + 1;
        end loop;
        return ret;
    end function;
      function esl_conv_string_hex (lv : STD_LOGIC_VECTOR) return STRING is
          constant str_len : integer := (lv'length + 3)/4;
          variable ret : STRING (1 to str_len);
          variable i, tmp: INTEGER;
          variable normal_lv : STD_LOGIC_VECTOR(lv'length - 1 downto 0);
          variable tmp_lv : STD_LOGIC_VECTOR(3 downto 0);
      begin
          normal_lv := lv;
          for i in 1 to str_len loop
              if(i = 1) then
                  if((lv'length mod 4) = 3) then
                      tmp_lv(2 downto 0) := normal_lv(lv'length - 1 downto lv'length - 3);
                      case tmp_lv(2 downto 0) is
                          when "000" => ret(i) := '0';
                          when "001" => ret(i) := '1';
                          when "010" => ret(i) := '2';
                          when "011" => ret(i) := '3';
                          when "100" => ret(i) := '4';
                          when "101" => ret(i) := '5';
                          when "110" => ret(i) := '6';
                          when "111" => ret(i) := '7';
                          when others  => ret(i) := '0';
                      end case;
                  elsif((lv'length mod 4) = 2) then
                      tmp_lv(1 downto 0) := normal_lv(lv'length - 1 downto lv'length - 2);
                      case tmp_lv(1 downto 0) is
                          when "00" => ret(i) := '0';
                          when "01" => ret(i) := '1';
                          when "10" => ret(i) := '2';
                          when "11" => ret(i) := '3';
                          when others => ret(i) := '0';
                      end case;
                  elsif((lv'length mod 4) = 1) then
                      tmp_lv(0 downto 0) := normal_lv(lv'length - 1 downto lv'length - 1);
                      case tmp_lv(0 downto 0) is
                          when "0" => ret(i) := '0';
                          when "1" => ret(i) := '1';
                          when others=> ret(i) := '0';
                      end case;
                  elsif((lv'length mod 4) = 0) then
                      tmp_lv(3 downto 0) := normal_lv(lv'length - 1 downto lv'length - 4);
                      case tmp_lv(3 downto 0) is
                          when "0000" => ret(i) := '0';
                          when "0001" => ret(i) := '1';
                          when "0010" => ret(i) := '2';
                          when "0011" => ret(i) := '3';
                          when "0100" => ret(i) := '4';
                          when "0101" => ret(i) := '5';
                          when "0110" => ret(i) := '6';
                          when "0111" => ret(i) := '7';
                          when "1000" => ret(i) := '8';
                          when "1001" => ret(i) := '9';
                          when "1010" => ret(i) := 'a';
                          when "1011" => ret(i) := 'b';
                          when "1100" => ret(i) := 'c';
                          when "1101" => ret(i) := 'd';
                          when "1110" => ret(i) := 'e';
                          when "1111" => ret(i) := 'f';
                          when others   => ret(i) := '0';
                      end case;
                  end if;
              else
                  tmp_lv(3 downto 0) := normal_lv((str_len - i) * 4 + 3 downto (str_len - i) * 4);
                  case tmp_lv(3 downto 0) is
                      when "0000" => ret(i) := '0';
                      when "0001" => ret(i) := '1';
                      when "0010" => ret(i) := '2';
                      when "0011" => ret(i) := '3';
                      when "0100" => ret(i) := '4';
                      when "0101" => ret(i) := '5';
                      when "0110" => ret(i) := '6';
                      when "0111" => ret(i) := '7';
                      when "1000" => ret(i) := '8';
                      when "1001" => ret(i) := '9';
                      when "1010" => ret(i) := 'a';
                      when "1011" => ret(i) := 'b';
                      when "1100" => ret(i) := 'c';
                      when "1101" => ret(i) := 'd';
                      when "1110" => ret(i) := 'e';
                      when "1111" => ret(i) := 'f';
                      when others   => ret(i) := '0';
                  end case;
              end if;
          end loop;
          return ret;
      end function;

  -- purpose: initialise the random state variable based on an integer seed
  function init_rand(seed : integer) return T_RANDINT is
    variable result : T_RANDINT;
  begin
    -- If the seed is smaller than the minimum value of the random state variable, use the minimum value
    if seed < T_RANDINT'low then
      result := T_RANDINT'low;
      -- If the seed is larger than the maximum value of the random state variable, use the maximum value
    elsif seed > T_RANDINT'high then
      result := T_RANDINT'high;
      -- If the seed is within the range of the random state variable, just use the seed
    else
      result := seed;
    end if;
    -- Return the result
    return result;
  end init_rand;


  -- purpose: generate a random integer between min and max limits
  procedure rand_int(variable rand   : inout T_RANDINT;
                     constant minval : in    integer;
                     constant maxval : in    integer;
                     variable result : out   integer
                     ) is

    variable k, q      : integer;
    variable real_rand : real;
    variable res       : integer;

  begin
    -- Create a new random integer in the range 1 to 2**31-1 and put it back into rand VARIABLE
    -- Based on an example from Numerical Recipes in C, 2nd Edition, page 279
    k   := rand/127773;
    q   := 16807*(rand-k*127773)-2836*k;
    if q < 0 then
      q := q + 2147483647;
    end if;
    rand := init_rand(q);

    -- Convert this integer to a real number in the range 0 to 1
    real_rand := (real(rand - T_RANDINT'low)) / real(T_RANDINT'high - T_RANDINT'low);
    -- Convert this real number to an integer in the range minval to maxval
    -- The +1 and -0.5 are to get equal probability of minval and maxval as other values
    res    := integer((real_rand * real(maxval+1-minval)) - 0.5) + minval;
    -- VHDL real to integer conversion doesn't define what happens for x.5 so deal with this
    if res < minval then
      res  := minval;
    elsif res > maxval then
      res  := maxval;
    end if;
    -- assign output
    result := res;

  end rand_int;

begin
AESL_inst_nfa_accept_samples_generic_hw    :   nfa_accept_samples_generic_hw port map (
   ap_clk  =>  ap_clk,
   ap_rst  =>  ap_rst,
   ap_start  =>  ap_start,
   ap_done  =>  ap_done,
   ap_idle  =>  ap_idle,
   ap_ready  =>  ap_ready,
   nfa_initials_buckets_req_din  =>  nfa_initials_buckets_req_din,
   nfa_initials_buckets_req_full_n  =>  nfa_initials_buckets_req_full_n,
   nfa_initials_buckets_req_write  =>  nfa_initials_buckets_req_write,
   nfa_initials_buckets_rsp_empty_n  =>  nfa_initials_buckets_rsp_empty_n,
   nfa_initials_buckets_rsp_read  =>  nfa_initials_buckets_rsp_read,
   nfa_initials_buckets_address  =>  nfa_initials_buckets_address,
   nfa_initials_buckets_datain  =>  nfa_initials_buckets_datain,
   nfa_initials_buckets_dataout  =>  nfa_initials_buckets_dataout,
   nfa_initials_buckets_size  =>  nfa_initials_buckets_size,
   nfa_finals_buckets_req_din  =>  nfa_finals_buckets_req_din,
   nfa_finals_buckets_req_full_n  =>  nfa_finals_buckets_req_full_n,
   nfa_finals_buckets_req_write  =>  nfa_finals_buckets_req_write,
   nfa_finals_buckets_rsp_empty_n  =>  nfa_finals_buckets_rsp_empty_n,
   nfa_finals_buckets_rsp_read  =>  nfa_finals_buckets_rsp_read,
   nfa_finals_buckets_address  =>  nfa_finals_buckets_address,
   nfa_finals_buckets_datain  =>  nfa_finals_buckets_datain,
   nfa_finals_buckets_dataout  =>  nfa_finals_buckets_dataout,
   nfa_finals_buckets_size  =>  nfa_finals_buckets_size,
   nfa_forward_buckets_req_din  =>  nfa_forward_buckets_req_din,
   nfa_forward_buckets_req_full_n  =>  nfa_forward_buckets_req_full_n,
   nfa_forward_buckets_req_write  =>  nfa_forward_buckets_req_write,
   nfa_forward_buckets_rsp_empty_n  =>  nfa_forward_buckets_rsp_empty_n,
   nfa_forward_buckets_rsp_read  =>  nfa_forward_buckets_rsp_read,
   nfa_forward_buckets_address  =>  nfa_forward_buckets_address,
   nfa_forward_buckets_datain  =>  nfa_forward_buckets_datain,
   nfa_forward_buckets_dataout  =>  nfa_forward_buckets_dataout,
   nfa_forward_buckets_size  =>  nfa_forward_buckets_size,
   nfa_symbols  =>  nfa_symbols,
   sample_buffer_req_din  =>  sample_buffer_req_din,
   sample_buffer_req_full_n  =>  sample_buffer_req_full_n,
   sample_buffer_req_write  =>  sample_buffer_req_write,
   sample_buffer_rsp_empty_n  =>  sample_buffer_rsp_empty_n,
   sample_buffer_rsp_read  =>  sample_buffer_rsp_read,
   sample_buffer_address  =>  sample_buffer_address,
   sample_buffer_datain  =>  sample_buffer_datain,
   sample_buffer_dataout  =>  sample_buffer_dataout,
   sample_buffer_size  =>  sample_buffer_size,
   sample_buffer_length  =>  sample_buffer_length,
   sample_length  =>  sample_length,
   indices_begin_req_din  =>  indices_begin_req_din,
   indices_begin_req_full_n  =>  indices_begin_req_full_n,
   indices_begin_req_write  =>  indices_begin_req_write,
   indices_begin_rsp_empty_n  =>  indices_begin_rsp_empty_n,
   indices_begin_rsp_read  =>  indices_begin_rsp_read,
   indices_begin_address  =>  indices_begin_address,
   indices_begin_datain  =>  indices_begin_datain,
   indices_begin_dataout  =>  indices_begin_dataout,
   indices_begin_size  =>  indices_begin_size,
   indices_samples_req_din  =>  indices_samples_req_din,
   indices_samples_req_full_n  =>  indices_samples_req_full_n,
   indices_samples_req_write  =>  indices_samples_req_write,
   indices_samples_rsp_empty_n  =>  indices_samples_rsp_empty_n,
   indices_samples_rsp_read  =>  indices_samples_rsp_read,
   indices_samples_address  =>  indices_samples_address,
   indices_samples_datain  =>  indices_samples_datain,
   indices_samples_dataout  =>  indices_samples_dataout,
   indices_samples_size  =>  indices_samples_size,
   indices_stride_req_din  =>  indices_stride_req_din,
   indices_stride_req_full_n  =>  indices_stride_req_full_n,
   indices_stride_req_write  =>  indices_stride_req_write,
   indices_stride_rsp_empty_n  =>  indices_stride_rsp_empty_n,
   indices_stride_rsp_read  =>  indices_stride_rsp_read,
   indices_stride_address  =>  indices_stride_address,
   indices_stride_datain  =>  indices_stride_datain,
   indices_stride_dataout  =>  indices_stride_dataout,
   indices_stride_size  =>  indices_stride_size,
   i_size  =>  i_size,
   begin_index  =>  begin_index,
   begin_sample  =>  begin_sample,
   end_index  =>  end_index,
   end_sample  =>  end_sample,
   stop_on_first  =>  stop_on_first,
   accept  =>  accept,
   ap_return  =>  ap_return
);

-- Assignment for control signal
  ap_clk <= AESL_clock;
  ap_rst <= AESL_reset;
  AESL_reset <= rst;
  ap_start <= AESL_start;
  AESL_start <= start;
  AESL_done <= ap_done;
  AESL_idle <= ap_idle;
  AESL_ready <= ap_ready;
  AESL_ce <= ce;
  AESL_continue <= continue;
AESL_inst_nfa_initials_buckets : AESL_autobus_nfa_initials_buckets port map (
        clk             =>   AESL_clock,
        rst             =>   AESL_reset,
        bus_req_RW      =>   bus_nfa_initials_buckets_req_RW,
        bus_req_full_n  =>   bus_nfa_initials_buckets_req_full_n,
        bus_req_RW_en   =>   bus_nfa_initials_buckets_req_RW_en,
        bus_rsp_empty_n =>   bus_nfa_initials_buckets_rsp_empty_n,
        bus_rsp_read    =>   bus_nfa_initials_buckets_rsp_read,
        bus_address     =>   bus_nfa_initials_buckets_address,
        bus_din         =>   bus_nfa_initials_buckets_din,
        bus_dout        =>   bus_nfa_initials_buckets_dout,
        bus_size        =>   bus_nfa_initials_buckets_size,
        ready           =>   bus_nfa_initials_buckets_ready,
        done            =>   bus_nfa_initials_buckets_done
    );

-- Assignment between dut and bus nfa_initials_buckets

-- Assign input of bus nfa_initials_buckets
bus_nfa_initials_buckets_req_RW	    <=   nfa_initials_buckets_req_din;
bus_nfa_initials_buckets_req_RW_en	<=   nfa_initials_buckets_req_write and nfa_initials_buckets_req_full_n;
bus_nfa_initials_buckets_rsp_read	<=   nfa_initials_buckets_rsp_read and nfa_initials_buckets_rsp_empty_n;
bus_nfa_initials_buckets_address	<=   nfa_initials_buckets_address;
bus_nfa_initials_buckets_din		<=   nfa_initials_buckets_dataout;
bus_nfa_initials_buckets_size	    <=   nfa_initials_buckets_size;
bus_nfa_initials_buckets_ready	    <=   ready;
-- Assign input of dut
nfa_initials_buckets_datain	        <=   bus_nfa_initials_buckets_dout;
gen_reg_bus_nfa_initials_buckets_req_full_n_proc : process
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    reg_bus_nfa_initials_buckets_req_full_n <= '0';
    while(true) loop
        wait until bus_nfa_initials_buckets_req_full_n'event;
        if(bus_nfa_initials_buckets_req_full_n = '1') then
        end if;
        reg_bus_nfa_initials_buckets_req_full_n <= bus_nfa_initials_buckets_req_full_n;
    end loop;
end process;

nfa_initials_buckets_req_full_n    <=   reg_bus_nfa_initials_buckets_req_full_n;
gen_reg_bus_nfa_initials_buckets_rsp_empty_n_proc : process
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    reg_bus_nfa_initials_buckets_rsp_empty_n <= '0';
    while(true) loop
        wait until bus_nfa_initials_buckets_rsp_empty_n'event;
        if(bus_nfa_initials_buckets_rsp_empty_n = '1') then
        end if;
        reg_bus_nfa_initials_buckets_rsp_empty_n <= bus_nfa_initials_buckets_rsp_empty_n;
    end loop;
end process;

nfa_initials_buckets_rsp_empty_n    <=   reg_bus_nfa_initials_buckets_rsp_empty_n;

AESL_inst_nfa_finals_buckets : AESL_autobus_nfa_finals_buckets port map (
        clk             =>   AESL_clock,
        rst             =>   AESL_reset,
        bus_req_RW      =>   bus_nfa_finals_buckets_req_RW,
        bus_req_full_n  =>   bus_nfa_finals_buckets_req_full_n,
        bus_req_RW_en   =>   bus_nfa_finals_buckets_req_RW_en,
        bus_rsp_empty_n =>   bus_nfa_finals_buckets_rsp_empty_n,
        bus_rsp_read    =>   bus_nfa_finals_buckets_rsp_read,
        bus_address     =>   bus_nfa_finals_buckets_address,
        bus_din         =>   bus_nfa_finals_buckets_din,
        bus_dout        =>   bus_nfa_finals_buckets_dout,
        bus_size        =>   bus_nfa_finals_buckets_size,
        ready           =>   bus_nfa_finals_buckets_ready,
        done            =>   bus_nfa_finals_buckets_done
    );

-- Assignment between dut and bus nfa_finals_buckets

-- Assign input of bus nfa_finals_buckets
bus_nfa_finals_buckets_req_RW	    <=   nfa_finals_buckets_req_din;
bus_nfa_finals_buckets_req_RW_en	<=   nfa_finals_buckets_req_write and nfa_finals_buckets_req_full_n;
bus_nfa_finals_buckets_rsp_read	<=   nfa_finals_buckets_rsp_read and nfa_finals_buckets_rsp_empty_n;
bus_nfa_finals_buckets_address	<=   nfa_finals_buckets_address;
bus_nfa_finals_buckets_din		<=   nfa_finals_buckets_dataout;
bus_nfa_finals_buckets_size	    <=   nfa_finals_buckets_size;
bus_nfa_finals_buckets_ready	    <=   ready;
-- Assign input of dut
nfa_finals_buckets_datain	        <=   bus_nfa_finals_buckets_dout;
gen_reg_bus_nfa_finals_buckets_req_full_n_proc : process
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    reg_bus_nfa_finals_buckets_req_full_n <= '0';
    while(true) loop
        wait until bus_nfa_finals_buckets_req_full_n'event;
        if(bus_nfa_finals_buckets_req_full_n = '1') then
        end if;
        reg_bus_nfa_finals_buckets_req_full_n <= bus_nfa_finals_buckets_req_full_n;
    end loop;
end process;

nfa_finals_buckets_req_full_n    <=   reg_bus_nfa_finals_buckets_req_full_n;
gen_reg_bus_nfa_finals_buckets_rsp_empty_n_proc : process
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    reg_bus_nfa_finals_buckets_rsp_empty_n <= '0';
    while(true) loop
        wait until bus_nfa_finals_buckets_rsp_empty_n'event;
        if(bus_nfa_finals_buckets_rsp_empty_n = '1') then
        end if;
        reg_bus_nfa_finals_buckets_rsp_empty_n <= bus_nfa_finals_buckets_rsp_empty_n;
    end loop;
end process;

nfa_finals_buckets_rsp_empty_n    <=   reg_bus_nfa_finals_buckets_rsp_empty_n;

AESL_inst_nfa_forward_buckets : AESL_autobus_nfa_forward_buckets port map (
        clk             =>   AESL_clock,
        rst             =>   AESL_reset,
        bus_req_RW      =>   bus_nfa_forward_buckets_req_RW,
        bus_req_full_n  =>   bus_nfa_forward_buckets_req_full_n,
        bus_req_RW_en   =>   bus_nfa_forward_buckets_req_RW_en,
        bus_rsp_empty_n =>   bus_nfa_forward_buckets_rsp_empty_n,
        bus_rsp_read    =>   bus_nfa_forward_buckets_rsp_read,
        bus_address     =>   bus_nfa_forward_buckets_address,
        bus_din         =>   bus_nfa_forward_buckets_din,
        bus_dout        =>   bus_nfa_forward_buckets_dout,
        bus_size        =>   bus_nfa_forward_buckets_size,
        ready           =>   bus_nfa_forward_buckets_ready,
        done            =>   bus_nfa_forward_buckets_done
    );

-- Assignment between dut and bus nfa_forward_buckets

-- Assign input of bus nfa_forward_buckets
bus_nfa_forward_buckets_req_RW	    <=   nfa_forward_buckets_req_din;
bus_nfa_forward_buckets_req_RW_en	<=   nfa_forward_buckets_req_write and nfa_forward_buckets_req_full_n;
bus_nfa_forward_buckets_rsp_read	<=   nfa_forward_buckets_rsp_read and nfa_forward_buckets_rsp_empty_n;
bus_nfa_forward_buckets_address	<=   nfa_forward_buckets_address;
bus_nfa_forward_buckets_din		<=   nfa_forward_buckets_dataout;
bus_nfa_forward_buckets_size	    <=   nfa_forward_buckets_size;
bus_nfa_forward_buckets_ready	    <=   ready;
-- Assign input of dut
nfa_forward_buckets_datain	        <=   bus_nfa_forward_buckets_dout;
gen_reg_bus_nfa_forward_buckets_req_full_n_proc : process
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    reg_bus_nfa_forward_buckets_req_full_n <= '0';
    while(true) loop
        wait until bus_nfa_forward_buckets_req_full_n'event;
        if(bus_nfa_forward_buckets_req_full_n = '1') then
        end if;
        reg_bus_nfa_forward_buckets_req_full_n <= bus_nfa_forward_buckets_req_full_n;
    end loop;
end process;

nfa_forward_buckets_req_full_n    <=   reg_bus_nfa_forward_buckets_req_full_n;
gen_reg_bus_nfa_forward_buckets_rsp_empty_n_proc : process
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    reg_bus_nfa_forward_buckets_rsp_empty_n <= '0';
    while(true) loop
        wait until bus_nfa_forward_buckets_rsp_empty_n'event;
        if(bus_nfa_forward_buckets_rsp_empty_n = '1') then
        end if;
        reg_bus_nfa_forward_buckets_rsp_empty_n <= bus_nfa_forward_buckets_rsp_empty_n;
    end loop;
end process;

nfa_forward_buckets_rsp_empty_n    <=   reg_bus_nfa_forward_buckets_rsp_empty_n;

-- Assignment between dut and arraynfa_backward_buckets
arraynfa_backward_buckets_done <= '0';

gen_assign_nfa_symbols_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  nfa_symbols <= AESL_REG_nfa_symbols;
end process;
read_file_process_nfa_symbols : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 280);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_nfa_symbols, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_nfa_symbols & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        report "The token is " & token;
        assert false report "Illegal format of [[[runtime]]] part in " & AUTOTB_TVIN_nfa_symbols severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            report "The token is " & token;
            assert false report "Illegal format of [[transaction]] part in " & AUTOTB_TVIN_nfa_symbols severity note;
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait until AESL_clock'event and AESL_clock = '1';
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_nfa_symbols := esl_str2lv_hex(token, 8 );
            esl_read_token(fp, token_line, token);
        end if;
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

AESL_inst_sample_buffer : AESL_autobus_sample_buffer port map (
        clk             =>   AESL_clock,
        rst             =>   AESL_reset,
        bus_req_RW      =>   bus_sample_buffer_req_RW,
        bus_req_full_n  =>   bus_sample_buffer_req_full_n,
        bus_req_RW_en   =>   bus_sample_buffer_req_RW_en,
        bus_rsp_empty_n =>   bus_sample_buffer_rsp_empty_n,
        bus_rsp_read    =>   bus_sample_buffer_rsp_read,
        bus_address     =>   bus_sample_buffer_address,
        bus_din         =>   bus_sample_buffer_din,
        bus_dout        =>   bus_sample_buffer_dout,
        bus_size        =>   bus_sample_buffer_size,
        ready           =>   bus_sample_buffer_ready,
        done            =>   bus_sample_buffer_done
    );

-- Assignment between dut and bus sample_buffer

-- Assign input of bus sample_buffer
bus_sample_buffer_req_RW	    <=   sample_buffer_req_din;
bus_sample_buffer_req_RW_en	<=   sample_buffer_req_write and sample_buffer_req_full_n;
bus_sample_buffer_rsp_read	<=   sample_buffer_rsp_read and sample_buffer_rsp_empty_n;
bus_sample_buffer_address	<=   sample_buffer_address;
bus_sample_buffer_din		<=   sample_buffer_dataout;
bus_sample_buffer_size	    <=   sample_buffer_size;
bus_sample_buffer_ready	    <=   ready;
-- Assign input of dut
sample_buffer_datain	        <=   bus_sample_buffer_dout;
gen_reg_bus_sample_buffer_req_full_n_proc : process
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    reg_bus_sample_buffer_req_full_n <= '0';
    while(true) loop
        wait until bus_sample_buffer_req_full_n'event;
        if(bus_sample_buffer_req_full_n = '1') then
        end if;
        reg_bus_sample_buffer_req_full_n <= bus_sample_buffer_req_full_n;
    end loop;
end process;

sample_buffer_req_full_n    <=   reg_bus_sample_buffer_req_full_n;
gen_reg_bus_sample_buffer_rsp_empty_n_proc : process
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    reg_bus_sample_buffer_rsp_empty_n <= '0';
    while(true) loop
        wait until bus_sample_buffer_rsp_empty_n'event;
        if(bus_sample_buffer_rsp_empty_n = '1') then
        end if;
        reg_bus_sample_buffer_rsp_empty_n <= bus_sample_buffer_rsp_empty_n;
    end loop;
end process;

sample_buffer_rsp_empty_n    <=   reg_bus_sample_buffer_rsp_empty_n;

gen_assign_sample_buffer_length_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  sample_buffer_length <= AESL_REG_sample_buffer_length;
end process;
read_file_process_sample_buffer_length : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 280);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_sample_buffer_length, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_sample_buffer_length & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        report "The token is " & token;
        assert false report "Illegal format of [[[runtime]]] part in " & AUTOTB_TVIN_sample_buffer_length severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            report "The token is " & token;
            assert false report "Illegal format of [[transaction]] part in " & AUTOTB_TVIN_sample_buffer_length severity note;
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait until AESL_clock'event and AESL_clock = '1';
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_sample_buffer_length := esl_str2lv_hex(token, 32 );
            esl_read_token(fp, token_line, token);
        end if;
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_sample_length_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  sample_length <= AESL_REG_sample_length;
end process;
read_file_process_sample_length : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 280);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_sample_length, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_sample_length & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        report "The token is " & token;
        assert false report "Illegal format of [[[runtime]]] part in " & AUTOTB_TVIN_sample_length severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            report "The token is " & token;
            assert false report "Illegal format of [[transaction]] part in " & AUTOTB_TVIN_sample_length severity note;
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait until AESL_clock'event and AESL_clock = '1';
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_sample_length := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

AESL_inst_indices_begin : AESL_autobus_indices_begin port map (
        clk             =>   AESL_clock,
        rst             =>   AESL_reset,
        bus_req_RW      =>   bus_indices_begin_req_RW,
        bus_req_full_n  =>   bus_indices_begin_req_full_n,
        bus_req_RW_en   =>   bus_indices_begin_req_RW_en,
        bus_rsp_empty_n =>   bus_indices_begin_rsp_empty_n,
        bus_rsp_read    =>   bus_indices_begin_rsp_read,
        bus_address     =>   bus_indices_begin_address,
        bus_din         =>   bus_indices_begin_din,
        bus_dout        =>   bus_indices_begin_dout,
        bus_size        =>   bus_indices_begin_size,
        ready           =>   bus_indices_begin_ready,
        done            =>   bus_indices_begin_done
    );

-- Assignment between dut and bus indices_begin

-- Assign input of bus indices_begin
bus_indices_begin_req_RW	    <=   indices_begin_req_din;
bus_indices_begin_req_RW_en	<=   indices_begin_req_write and indices_begin_req_full_n;
bus_indices_begin_rsp_read	<=   indices_begin_rsp_read and indices_begin_rsp_empty_n;
bus_indices_begin_address	<=   indices_begin_address;
bus_indices_begin_din		<=   indices_begin_dataout;
bus_indices_begin_size	    <=   indices_begin_size;
bus_indices_begin_ready	    <=   ready;
-- Assign input of dut
indices_begin_datain	        <=   bus_indices_begin_dout;
gen_reg_bus_indices_begin_req_full_n_proc : process
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    reg_bus_indices_begin_req_full_n <= '0';
    while(true) loop
        wait until bus_indices_begin_req_full_n'event;
        if(bus_indices_begin_req_full_n = '1') then
        end if;
        reg_bus_indices_begin_req_full_n <= bus_indices_begin_req_full_n;
    end loop;
end process;

indices_begin_req_full_n    <=   reg_bus_indices_begin_req_full_n;
gen_reg_bus_indices_begin_rsp_empty_n_proc : process
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    reg_bus_indices_begin_rsp_empty_n <= '0';
    while(true) loop
        wait until bus_indices_begin_rsp_empty_n'event;
        if(bus_indices_begin_rsp_empty_n = '1') then
        end if;
        reg_bus_indices_begin_rsp_empty_n <= bus_indices_begin_rsp_empty_n;
    end loop;
end process;

indices_begin_rsp_empty_n    <=   reg_bus_indices_begin_rsp_empty_n;

AESL_inst_indices_samples : AESL_autobus_indices_samples port map (
        clk             =>   AESL_clock,
        rst             =>   AESL_reset,
        bus_req_RW      =>   bus_indices_samples_req_RW,
        bus_req_full_n  =>   bus_indices_samples_req_full_n,
        bus_req_RW_en   =>   bus_indices_samples_req_RW_en,
        bus_rsp_empty_n =>   bus_indices_samples_rsp_empty_n,
        bus_rsp_read    =>   bus_indices_samples_rsp_read,
        bus_address     =>   bus_indices_samples_address,
        bus_din         =>   bus_indices_samples_din,
        bus_dout        =>   bus_indices_samples_dout,
        bus_size        =>   bus_indices_samples_size,
        ready           =>   bus_indices_samples_ready,
        done            =>   bus_indices_samples_done
    );

-- Assignment between dut and bus indices_samples

-- Assign input of bus indices_samples
bus_indices_samples_req_RW	    <=   indices_samples_req_din;
bus_indices_samples_req_RW_en	<=   indices_samples_req_write and indices_samples_req_full_n;
bus_indices_samples_rsp_read	<=   indices_samples_rsp_read and indices_samples_rsp_empty_n;
bus_indices_samples_address	<=   indices_samples_address;
bus_indices_samples_din		<=   indices_samples_dataout;
bus_indices_samples_size	    <=   indices_samples_size;
bus_indices_samples_ready	    <=   ready;
-- Assign input of dut
indices_samples_datain	        <=   bus_indices_samples_dout;
gen_reg_bus_indices_samples_req_full_n_proc : process
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    reg_bus_indices_samples_req_full_n <= '0';
    while(true) loop
        wait until bus_indices_samples_req_full_n'event;
        if(bus_indices_samples_req_full_n = '1') then
        end if;
        reg_bus_indices_samples_req_full_n <= bus_indices_samples_req_full_n;
    end loop;
end process;

indices_samples_req_full_n    <=   reg_bus_indices_samples_req_full_n;
gen_reg_bus_indices_samples_rsp_empty_n_proc : process
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    reg_bus_indices_samples_rsp_empty_n <= '0';
    while(true) loop
        wait until bus_indices_samples_rsp_empty_n'event;
        if(bus_indices_samples_rsp_empty_n = '1') then
        end if;
        reg_bus_indices_samples_rsp_empty_n <= bus_indices_samples_rsp_empty_n;
    end loop;
end process;

indices_samples_rsp_empty_n    <=   reg_bus_indices_samples_rsp_empty_n;

AESL_inst_indices_stride : AESL_autobus_indices_stride port map (
        clk             =>   AESL_clock,
        rst             =>   AESL_reset,
        bus_req_RW      =>   bus_indices_stride_req_RW,
        bus_req_full_n  =>   bus_indices_stride_req_full_n,
        bus_req_RW_en   =>   bus_indices_stride_req_RW_en,
        bus_rsp_empty_n =>   bus_indices_stride_rsp_empty_n,
        bus_rsp_read    =>   bus_indices_stride_rsp_read,
        bus_address     =>   bus_indices_stride_address,
        bus_din         =>   bus_indices_stride_din,
        bus_dout        =>   bus_indices_stride_dout,
        bus_size        =>   bus_indices_stride_size,
        ready           =>   bus_indices_stride_ready,
        done            =>   bus_indices_stride_done
    );

-- Assignment between dut and bus indices_stride

-- Assign input of bus indices_stride
bus_indices_stride_req_RW	    <=   indices_stride_req_din;
bus_indices_stride_req_RW_en	<=   indices_stride_req_write and indices_stride_req_full_n;
bus_indices_stride_rsp_read	<=   indices_stride_rsp_read and indices_stride_rsp_empty_n;
bus_indices_stride_address	<=   indices_stride_address;
bus_indices_stride_din		<=   indices_stride_dataout;
bus_indices_stride_size	    <=   indices_stride_size;
bus_indices_stride_ready	    <=   ready;
-- Assign input of dut
indices_stride_datain	        <=   bus_indices_stride_dout;
gen_reg_bus_indices_stride_req_full_n_proc : process
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    reg_bus_indices_stride_req_full_n <= '0';
    while(true) loop
        wait until bus_indices_stride_req_full_n'event;
        if(bus_indices_stride_req_full_n = '1') then
        end if;
        reg_bus_indices_stride_req_full_n <= bus_indices_stride_req_full_n;
    end loop;
end process;

indices_stride_req_full_n    <=   reg_bus_indices_stride_req_full_n;
gen_reg_bus_indices_stride_rsp_empty_n_proc : process
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    reg_bus_indices_stride_rsp_empty_n <= '0';
    while(true) loop
        wait until bus_indices_stride_rsp_empty_n'event;
        if(bus_indices_stride_rsp_empty_n = '1') then
        end if;
        reg_bus_indices_stride_rsp_empty_n <= bus_indices_stride_rsp_empty_n;
    end loop;
end process;

indices_stride_rsp_empty_n    <=   reg_bus_indices_stride_rsp_empty_n;

gen_assign_i_size_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  i_size <= AESL_REG_i_size;
end process;
gen_assign_begin_index_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  begin_index <= AESL_REG_begin_index;
end process;
read_file_process_begin_index : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 280);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_begin_index, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_begin_index & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        report "The token is " & token;
        assert false report "Illegal format of [[[runtime]]] part in " & AUTOTB_TVIN_begin_index severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            report "The token is " & token;
            assert false report "Illegal format of [[transaction]] part in " & AUTOTB_TVIN_begin_index severity note;
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait until AESL_clock'event and AESL_clock = '1';
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_begin_index := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_begin_sample_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  begin_sample <= AESL_REG_begin_sample;
end process;
read_file_process_begin_sample : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 280);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_begin_sample, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_begin_sample & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        report "The token is " & token;
        assert false report "Illegal format of [[[runtime]]] part in " & AUTOTB_TVIN_begin_sample severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            report "The token is " & token;
            assert false report "Illegal format of [[transaction]] part in " & AUTOTB_TVIN_begin_sample severity note;
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait until AESL_clock'event and AESL_clock = '1';
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_begin_sample := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_end_index_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  end_index <= AESL_REG_end_index;
end process;
read_file_process_end_index : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 280);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_end_index, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_end_index & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        report "The token is " & token;
        assert false report "Illegal format of [[[runtime]]] part in " & AUTOTB_TVIN_end_index severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            report "The token is " & token;
            assert false report "Illegal format of [[transaction]] part in " & AUTOTB_TVIN_end_index severity note;
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait until AESL_clock'event and AESL_clock = '1';
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_end_index := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_end_sample_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  end_sample <= AESL_REG_end_sample;
end process;
read_file_process_end_sample : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 280);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_end_sample, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_end_sample & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        report "The token is " & token;
        assert false report "Illegal format of [[[runtime]]] part in " & AUTOTB_TVIN_end_sample severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            report "The token is " & token;
            assert false report "Illegal format of [[transaction]] part in " & AUTOTB_TVIN_end_sample severity note;
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait until AESL_clock'event and AESL_clock = '1';
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_end_sample := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_stop_on_first_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  stop_on_first <= AESL_REG_stop_on_first;
end process;
read_file_process_stop_on_first : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 280);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_stop_on_first, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_stop_on_first & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        report "The token is " & token;
        assert false report "Illegal format of [[[runtime]]] part in " & AUTOTB_TVIN_stop_on_first severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            report "The token is " & token;
            assert false report "Illegal format of [[transaction]] part in " & AUTOTB_TVIN_stop_on_first severity note;
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait until AESL_clock'event and AESL_clock = '1';
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_stop_on_first := esl_str2lv_hex(token, 1 );
            esl_read_token(fp, token_line, token);
        end if;
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_accept_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  accept <= AESL_REG_accept;
end process;
read_file_process_accept : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 280);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_accept, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_accept & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        report "The token is " & token;
        assert false report "Illegal format of [[[runtime]]] part in " & AUTOTB_TVIN_accept severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            report "The token is " & token;
            assert false report "Illegal format of [[transaction]] part in " & AUTOTB_TVIN_accept severity note;
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait until AESL_clock'event and AESL_clock = '1';
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_accept := esl_str2lv_hex(token, 1 );
            esl_read_token(fp, token_line, token);
        end if;
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

write_file_process_ap_return : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 280);
    variable  transaction_idx :   INTEGER;
    variable  ap_return_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_ap_return_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_ap_return_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        write(token_line, "0x" & esl_conv_string_hex(ap_return));
        writeline(fp, token_line);
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

generate_AESL_ready_cnt_proc : process
begin
    AESL_ready_cnt := 0;
    wait until AESL_reset = '0';
    while(AESL_ready_cnt /= AUTOTB_TRANSACTION_NUM) loop
        while(AESL_ready /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.4 ns;
        end loop;
        wait until AESL_clock'event and AESL_clock = '0';
        AESL_ready_cnt := AESL_ready_cnt + 1;
        wait until AESL_clock'event and AESL_clock = '1';
        wait for 0.4 ns;
    end loop;
end process;

generate_ready_cnt_proc   :   process
begin
    ready_cnt := 0;
    wait until AESL_reset = '0';
    while(ready_cnt /= AUTOTB_TRANSACTION_NUM) loop
        while(ready /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.4 ns;
        end loop;
        wait until AESL_clock'event and AESL_clock = '0';
        ready_cnt := ready_cnt + 1;
        wait until AESL_clock'event and AESL_clock = '1';
        wait for 0.4 ns;
    end loop;
    wait;
end process;

generate_done_cnt_proc    :   process
begin
    done_cnt := 0;
    wait until AESL_reset = '0';
    while(done_cnt /= AUTOTB_TRANSACTION_NUM) loop
        while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.4 ns;
        end loop;
        wait until AESL_clock'event and AESL_clock = '0';
        done_cnt := done_cnt + 1;
        wait until AESL_clock'event and AESL_clock = '1';
        wait for 0.4 ns;
    end loop;
    wait until AESL_clock'event and AESL_clock = '1';
    wait for 0.4 ns;
    assert false report "simulation done!" severity note;
    assert false report "NORMAL EXIT (note: failure is to force the simulator to stop)" severity failure;
    wait;
end process;

gen_clock_proc :   process
begin
    AESL_clock <= '0';
    while(true) loop
        wait for (AUTOTB_CLOCK_PERIOD/2.0);
        AESL_clock <= not AESL_clock;
    end loop;
    wait;
end process;

gen_reset_proc : process
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    rst <= '1';
    wait for 100 ns;
    for i in 1 to 3 loop
        wait until AESL_clock'event and AESL_clock = '1';
    end loop;
    rst <= '0';
    wait;
end process;

gen_start_proc : process
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
  start <= '0';
  ce <= '1';
    wait until AESL_reset = '0';
  wait until (AESL_clock'event and AESL_clock = '1');
  start <= '1';
  while(ready_cnt /= AUTOTB_TRANSACTION_NUM + 1) loop
      wait until (AESL_clock'event and AESL_clock = '1');
      if(AESL_ready = '1') then
          start <= '0';
          start <= '1';
      end if;
  end loop;
  start <= '0';
  wait;
end process;


gen_continue_proc : process(AESL_done)
begin
    continue <= AESL_done;
end process;

gen_ready_initial_proc : process
begin
    ready_initial <= '0';
    wait until AESL_start = '1';
    ready_initial <= '1';
    wait until AESL_clock'event and AESL_clock = '1';
    ready_initial <= '0';
    wait;
end process;

gen_AESL_ready_delay_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
          AESL_ready_delay <= '0';
      else
          AESL_ready_delay <= AESL_ready;
      end if;
  end if;
end process;

ready_last_n_proc : process
begin
  ready_last_n <= '1';
  while(ready_cnt /= AUTOTB_TRANSACTION_NUM) loop
    wait until AESL_clock'event and AESL_clock = '1';
  end loop;
  ready_last_n <= '0';
  wait;
end process;

gen_ready_delay_n_last_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
          ready_delay_last_n <= '0';
      else
          ready_delay_last_n <= ready_last_n;
      end if;
  end if;
end process;

ready <= (ready_initial or AESL_ready_delay);
ready_wire <= ready_initial or AESL_ready_delay;
gen_done_delay_last_n_proc : process
begin
  done_delay_last_n <= '1';
  while(done_cnt /= AUTOTB_TRANSACTION_NUM) loop
      wait until (AESL_clock'event and AESL_clock = '1');
  end loop;
  done_delay_last_n <= '0';
  wait;
end process;

gen_done_delay_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
          AESL_done_delay <= '0';
          AESL_done_delay2 <= '0';
      else
          AESL_done_delay <= AESL_done and done_delay_last_n;
          AESL_done_delay2 <= AESL_done_delay;
      end if;
  end if;
end process;

gen_interface_done : process(ready, AESL_done_delay)
begin
    if(ready_cnt > 0 and ready_cnt < AUTOTB_TRANSACTION_NUM) then
        interface_done <= ready;
    elsif(ready_cnt = AUTOTB_TRANSACTION_NUM) then
        interface_done <= AESL_done_delay;
    else
        interface_done <= '0';
    end if;
end process;

gen_clock_counter_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_clk_counter := 0;
    else
        AESL_clk_counter := AESL_clk_counter + 1;
    end if;
  end if;
end process;

gen_mLatcnterout_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
          AESL_mLatCnterOut_addr := 0;
          AESL_mLatCnterOut(AESL_mLatCnterOut_addr) := AESL_clk_counter + 1 ;
      else
          if (AESL_done = '1' and AESL_mLatCnterOut_addr < AUTOTB_TRANSACTION_NUM + 1) then
              AESL_mLatCnterOut(AESL_mLatCnterOut_addr) := AESL_clk_counter;
              AESL_mLatCnterOut_addr := AESL_mLatCnterOut_addr + 1;
          end if;
      end if;
  end if;
end process;

gen_mLatcnterin_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
          AESL_mLatCnterIn_addr := 0;
      else
    if (AESL_start = '1' and AESL_mLatCnterIn_addr = 0) then
        AESL_mLatCnterIn(AESL_mLatCnterIn_addr) := AESL_clk_counter;
        AESL_mLatCnterIn_addr := AESL_mLatCnterIn_addr + 1;
    end if;
    if (AESL_ready = '1' and AESL_mLatCnterIn_addr < AUTOTB_TRANSACTION_NUM + 1 ) then
        AESL_mLatCnterIn(AESL_mLatCnterIn_addr) := AESL_clk_counter;
        AESL_mLatCnterIn_addr := AESL_mLatCnterIn_addr + 1;
    end if;
      end if;
  end if;
end process;

gen_performance_check_proc : process
    variable transaction_counter : INTEGER;
    variable i : INTEGER;
    file     fp :   TEXT;
    variable    fstatus         :   FILE_OPEN_STATUS;
    variable    token_line      :   LINE;
    variable    token           :   STRING(1 to 1024);

    variable latthistime : INTEGER;
    variable lattotal : INTEGER;
    variable latmax : INTEGER;
    variable latmin : INTEGER;


    variable thrthistime : INTEGER;
    variable thrtotal : INTEGER;
    variable thrmax : INTEGER;
    variable thrmin : INTEGER;

    variable lataver : INTEGER;
    variable thraver : INTEGER;
    type latency_record is array(0 to AUTOTB_TRANSACTION_NUM + 1) of INTEGER;
    variable lat_array : latency_record;
    variable thr_array : latency_record;

begin
    i := 0;
    lattotal  := 0;
    latmax    := 0;
    latmin    := 16#7fffffff#;
    lataver   := 0;

    thrtotal  := 0;
    thrmax    := 0;
    thrmin    := 16#7fffffff#;
    thraver   := 0;

    wait until (AESL_clock'event and AESL_clock = '1');
    wait until (AESL_reset = '0'); 
    while (done_cnt /= AUTOTB_TRANSACTION_NUM) loop
        wait until (AESL_clock'event and AESL_clock = '1');
    end loop;
  wait for 0.001 ns;

    if (AESL_mLatCnterIn_addr = 1 or AESL_mLatCnterIn_addr = 0 ) then
        latmax  := 0;
        latmin  := 0;
        lataver := 0;
        thrmax  := 0;
        thrmin  := 0;
        thraver := 0;
        lat_array(0) := 0;
        thr_array(0) := 0;
    elsif (AESL_mLatCnterOut_addr = 1 or AESL_mLatCnterOut_addr = 0 ) then
        latmax  := AESL_mLatCnterOut(0) - AESL_mLatCnterIn(0);
        latmin  := AESL_mLatCnterOut(0) - AESL_mLatCnterIn(0);
        lataver := AESL_mLatCnterOut(0) - AESL_mLatCnterIn(0);
        thrmax  := AESL_mLatCnterIn(1) - AESL_mLatCnterIn(0) + 1;
        thrmin  := AESL_mLatCnterIn(1) - AESL_mLatCnterIn(0) + 1;
        thraver := AESL_mLatCnterIn(1) - AESL_mLatCnterIn(0) + 1;
        lat_array(0) := lataver;
        thr_array(0) := thraver;
    else
    -- LATENCY
    for i in 0 to AESL_mLatCnterOut_addr - 1 loop
        latthistime := AESL_mLatCnterOut(i) - AESL_mLatCnterIn(i) ;
        if ( i > 0 ) then
            if (latthistime - 1 < 0) then
                latthistime := 0;
            else
                latthistime := latthistime - 1;
            end if;
        end if;
        lattotal := lattotal + latthistime;
        lat_array(i) := latthistime;
        if (latthistime > latmax) then
          latmax := latthistime;
        end if;
        if (latthistime < latmin) then
          latmin := latthistime;
        end if;
    end loop;
    -- II
    for i in 0 to AESL_mLatCnterIn_addr - 2 loop
        thrthistime := AESL_mLatCnterIn(i + 1) - AESL_mLatCnterIn(i);
        if ( i = 0 ) then
            thrthistime := thrthistime + 1;
        end if;
        thrtotal := thrtotal + thrthistime;
        thr_array(i) := thrthistime;
        if (thrthistime > thrmax) then
          thrmax := thrthistime;
        end if;
        if (thrthistime < thrmin) then
          thrmin := thrthistime;
        end if;
    end loop;
    
    thr_array(AESL_mLatCnterIn_addr - 1) := 0;
    lataver := lattotal / ( AESL_mLatCnterOut_addr);
    thraver := thrtotal / ( AESL_mLatCnterIn_addr - 1 );
    end if;

    file_open(fstatus, fp, AUTOTB_LAT_RESULT_FILE, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_LAT_RESULT_FILE & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    
    write(token_line, "$MAX_LATENCY = " & '"' & integer'image(latmax) & '"');
    writeline(fp, token_line);
    write(token_line, "$MIN_LATENCY = " & '"' & integer'image(latmin) & '"');
    writeline(fp, token_line);
    write(token_line, "$AVER_LATENCY = " & '"' & integer'image(lataver) & '"');
    writeline(fp, token_line);
    write(token_line, "$MAX_THROUGHPUT = " & '"' & integer'image(thrmax) & '"');
    writeline(fp, token_line);
    write(token_line, "$MIN_THROUGHPUT = " & '"' & integer'image(thrmin) & '"');
    writeline(fp, token_line);
    write(token_line, "$AVER_THROUGHPUT = " & '"' & integer'image(thraver) & '"');
    writeline(fp, token_line);
    file_close(fp);
    file_open(fstatus, fp, AUTOTB_PER_RESULT_TRANS_FILE, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_PER_RESULT_TRANS_FILE & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line,string'("                            latency            interval"));
    writeline(fp, token_line);
    for i in 0 to AESL_mLatCnterOut_addr - 1 loop
        write(token_line,"transaction        " & integer'image(i) & "            " & integer'image(lat_array(i) ) & "            " & integer'image(thr_array(i) ) );
        writeline(fp, token_line);
    end loop;

    file_close(fp);
    wait;
end process;

end behav;
