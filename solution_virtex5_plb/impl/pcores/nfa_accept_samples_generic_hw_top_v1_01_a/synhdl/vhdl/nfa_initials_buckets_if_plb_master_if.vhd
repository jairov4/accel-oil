-- ==============================================================
-- File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
-- Version: 2014.1
-- Copyright (C) 2014 Xilinx Inc. All rights reserved.
-- 
-- ==============================================================

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

entity nfa_initials_buckets_if_ap_fifo_uw is 
    generic (
        DATA_WIDTH : integer := 32;
        ADDR_WIDTH : integer := 4;
        DEPTH : integer := 16);
    port (
        clk : IN STD_LOGIC;
        reset : IN STD_LOGIC;
        if_empty_n : OUT STD_LOGIC;
        if_read : IN STD_LOGIC;
        if_dout : OUT STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0);
        if_full_n : OUT STD_LOGIC;
        if_write : IN STD_LOGIC;
        if_din : IN STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0);
  use_word: OUT STD_LOGIC_VECTOR(ADDR_WIDTH -1 downto 0));
end entity;

architecture rtl of nfa_initials_buckets_if_ap_fifo_uw is
    type memtype is array (0 to DEPTH - 1) of STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0);
    signal mStorage : memtype;
    signal mInPtr, mNextInPtr, mOutPtr : UNSIGNED(ADDR_WIDTH - 1 downto 0);
    signal internal_empty_n, internal_full_n : STD_LOGIC;
    signal internal_use_word : STD_LOGIC_VECTOR(ADDR_WIDTH -1 downto 0);
begin
    mNextInPtr <= mInPtr + 1;
    if_dout <= mStorage(CONV_INTEGER(mOutPtr));
    if_empty_n <= internal_empty_n;
    if_full_n <= internal_full_n;
    use_word <= internal_use_word;

    process (clk, reset)
    begin
        if reset = '1' then
            mInPtr <= (others => '0');
            mOutPtr <= (others => '0');
      internal_use_word <= (others => '0');
        else
            if clk'event and clk = '1' then
                if if_read = '1' and internal_empty_n = '1' then
                    mOutPtr <= mOutPtr + 1;
                end if;
                if if_write = '1' and internal_full_n = '1' then
                    mStorage(CONV_INTEGER(mInPtr)) <= if_din;
                    mInPtr <= mNextInPtr;
                end if;
                if (if_read = '1' and if_write = '0') then
                    internal_use_word <= internal_use_word - '1';
                elsif (if_read = '0' and if_write = '1') then
                    internal_use_word <= internal_use_word + '1';
                end if;
            end if;
        end if;
    end process;
   
    process (mInPtr, mOutPtr, mNextInPtr) 
    begin
        if mInPtr = mOutPtr then
            internal_empty_n <= '0';
        else
            internal_empty_n <= '1';
        end if;
        if mNextInPtr = mOutPtr then
            internal_full_n <= '0';
        else
            internal_full_n <= '1';
        end if;
    end process;
 
end architecture;

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

entity nfa_initials_buckets_if_plb_master_if is
  generic
  (
    C_PLB_AWIDTH                   : integer              := 32;
    C_PLB_DWIDTH                   : integer              := 64;
    PLB_ADDR_SHIFT                 : integer              := 3
  );
  port
  (
    -- ADD USER PORTS BELOW THIS LINE ------------------
    --USER ports added here
    -- ADD USER PORTS ABOVE THIS LINE ------------------

    -- DO NOT EDIT BELOW THIS LINE ---------------------
    -- Bus protocol ports, do not add to or delete
    PLB_Clk                        : in  std_logic;
    PLB_Rst                        : in  std_logic;

    M_abort                        : out std_logic;
    M_ABus                         : out std_logic_vector(0 to C_PLB_AWIDTH-1);
    M_BE                           : out std_logic_vector(0 to C_PLB_DWIDTH/8-1);
    M_busLock                      : out std_logic;
    M_lockErr                      : out std_logic;
    M_MSize                        : out std_logic_vector(0 to 1);
    M_priority                     : out std_logic_vector(0 to 1);
    M_rdBurst                      : out std_logic;
    M_request                      : out std_logic;
    M_RNW                          : out std_logic;
    M_size                         : out std_logic_vector(0 to 3);
    M_type                         : out std_logic_vector(0 to 2);
    M_wrBurst                      : out std_logic;
    M_wrDBus                       : out std_logic_vector(0 to C_PLB_DWIDTH-1);

    PLB_MBusy                      : in  std_logic;
    PLB_MWrBTerm                   : in  std_logic;
    PLB_MWrDAck                    : in  std_logic;
    PLB_MAddrAck                   : in  std_logic;
    PLB_MRdBTerm                   : in  std_logic;
    PLB_MRdDAck                    : in  std_logic;
    PLB_MRdDBus                    : in  std_logic_vector(0 to (C_PLB_DWIDTH-1));
    PLB_MRdWdAddr                  : in  std_logic_vector(0 to 3);
    PLB_MRearbitrate               : in  std_logic;
    PLB_MSSize                     : in  std_logic_vector(0 to 1);

    -- signals from user logic
    BUS_RdData     : out std_logic_vector(C_PLB_DWIDTH-1 downto 0);            -- Bus read return data to user_logic
    BUS_WrData     : in std_logic_vector(C_PLB_DWIDTH-1 downto 0);        -- Bus write data
    BUS_address    : in std_logic_vector(31 downto 0);        -- physical address
    BUS_size       : in std_logic_vector(31 downto 0);        -- burst size of word
    BUS_req_nRW    : in std_logic;                    -- req type 0: Read, 1: write
    BUS_req_BE     : in std_logic_vector(C_PLB_DWIDTH/8-1 downto 0);         -- Bus write data byte enable
    BUS_req_full_n : out std_logic;                -- req Fifo full
    BUS_req_push   : in std_logic;                    -- req Fifo push (new request in)
    BUS_rsp_nRW    : out std_logic;                -- return data FIFO rsp type
    BUS_rsp_empty_n: out std_logic;                -- return data FIFO empty
    BUS_rsp_pop    : in std_logic                    -- return data FIFO pop
  );

  attribute SIGIS : string;
  attribute SIGIS of PLB_Clk       : signal is "Clk";
  attribute SIGIS of PLB_Rst       : signal is "Rst";

end entity;

------------------------------------------------------------------------------
-- Architecture section
------------------------------------------------------------------------------

architecture IMP of nfa_initials_buckets_if_plb_master_if is

component nfa_initials_buckets_if_ap_fifo is 
    generic (
        DATA_WIDTH : integer := 32;
        ADDR_WIDTH : integer := 4;
        DEPTH : integer := 16);
    port (
        clk : IN STD_LOGIC;
        reset : IN STD_LOGIC;
        if_empty_n : OUT STD_LOGIC;
        if_read : IN STD_LOGIC;
        if_dout : OUT STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0);
        if_full_n : OUT STD_LOGIC;
        if_write : IN STD_LOGIC;
        if_din : IN STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0));
end component;

component nfa_initials_buckets_if_ap_fifo_uw is 
    generic (
        DATA_WIDTH : integer := 32;
        ADDR_WIDTH : integer := 4;
        DEPTH : integer := 16);
    port (
        clk : IN STD_LOGIC;
        reset : IN STD_LOGIC;
        if_empty_n : OUT STD_LOGIC;
        if_read : IN STD_LOGIC;
        if_dout : OUT STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0);
        if_full_n : OUT STD_LOGIC;
        if_write : IN STD_LOGIC;
        if_din : IN STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0);
        use_word: OUT STD_LOGIC_VECTOR(ADDR_WIDTH -1 downto 0));
end component;

  constant PLB_DW : integer := C_PLB_DWIDTH;
  constant PLB_BYTE_COUNT : integer := PLB_DW/8;
  constant REQ_FIFO_WIDTH : integer := 1 + PLB_BYTE_COUNT + 32 + 32;   --nRW + BE + 32 bits phy addr + size
  constant FIFO_ADDR_WIDTH : integer := 5;
  constant FIFO_DEPTH : integer := 32;

  -- request FIFO
  signal req_fifo_empty_n : STD_LOGIC;
  signal req_fifo_pop : STD_LOGIC;
  signal req_fifo_dout : STD_LOGIC_VECTOR(REQ_FIFO_WIDTH - 1 downto 0);
  signal req_fifo_full_n : STD_LOGIC;
  signal req_fifo_push : STD_LOGIC;
  signal req_fifo_din : STD_LOGIC_VECTOR(REQ_FIFO_WIDTH - 1 downto 0);

  -- burst write counter (only push burst data in and ignore all burst write request except the first one)
  signal req_burst_write: STD_LOGIC; -- whether last request is a burst write
  signal req_burst_write_counter: STD_LOGIC_VECTOR(31 downto 0);

  -- write data FIFO (for bus write data)
  signal wd_fifo_empty_n : STD_LOGIC;
  signal wd_fifo_pop : STD_LOGIC;
  signal wd_fifo_dout : STD_LOGIC_VECTOR(PLB_DW - 1 downto 0);
  signal wd_fifo_dout_mirror : STD_LOGIC_VECTOR(PLB_DW - 1 downto 0);
  signal wd_fifo_full_n : STD_LOGIC;
  signal wd_fifo_push : STD_LOGIC;
  signal wd_fifo_din : STD_LOGIC_VECTOR(PLB_DW - 1 downto 0);
  signal wd_fifo_use_word: STD_LOGIC_VECTOR(FIFO_ADDR_WIDTH -1 downto 0);

  -- read data FIFO (for bus read returned data)
  signal rd_fifo_empty_n : STD_LOGIC;
  signal rd_fifo_pop : STD_LOGIC;
  signal rd_fifo_dout : STD_LOGIC_VECTOR(PLB_DW - 1 downto 0);
  signal rd_fifo_full_n : STD_LOGIC;
  signal rd_fifo_push : STD_LOGIC;
  signal rd_fifo_din : STD_LOGIC_VECTOR(PLB_DW - 1 downto 0);
  signal rd_fifo_use_word: STD_LOGIC_VECTOR(FIFO_ADDR_WIDTH -1 downto 0);

  signal req_address     : std_logic_vector(0 to C_PLB_AWIDTH -1);-- bus request word address
  signal req_fifo_dout_req_size : std_logic_vector(31 downto 0);      -- req_size -1
  signal req_size     : std_logic_vector(0 to 27);        -- burst size of 16 word block
  signal request, req_nRW: std_logic;
  signal req_BE     : std_logic_vector(PLB_BYTE_COUNT-1 downto 0);

  signal pending_rd_req_burst_mode: std_logic;
  signal pending_rd_req_burst_size: std_logic_vector(3 downto 0);
  signal pending_wr_req_burst_mode: std_logic;
  signal pending_wr_req_burst_size: std_logic_vector(3 downto 0);
  signal pending_read, pending_write: std_logic;

  signal burst_mode, burst_last : std_logic;
  signal burst_size    : std_logic_vector(3 downto 0);    -- maximum burst 16 words 

  --signals for write data mirror
  signal conv_mode_comb : std_logic_vector(1 downto 0);  -- 00: NO conv, 01: 128/32, 10: 64/32, 11: 128/64
  signal conv_counter_comb: std_logic_vector(1 downto 0);
  signal wr_data_phase : std_logic;

  signal dataConv_last: std_logic;
  signal dp_dataConv_last: std_logic;
  signal dp_dataConv_word_addr: std_logic_vector(1 downto 0);
  signal dp_dataConv_wd_conv_mode : std_logic_vector(1 downto 0);  -- 00:NO conv, 01:128/32, 10:64/32, 11:128/64
  signal dp_dataConv_wd_burst_counter: std_logic_vector(1 downto 0);
  signal dp_dataConv_wd_BE: std_logic_vector(PLB_BYTE_COUNT-1 downto 0);
  signal dp_PLB_MSSize : std_logic_vector(1 downto 0);
  
  --signals for read data mirror
  signal PLB_MRdDAck_reg : std_logic;
  signal dp_dataConv_rd_conv_mode : std_logic_vector(1 downto 0);-- 00: NO conv, 01: 128/32, 10: 64/32, 11: 128/64
  signal dp_dataConv_rd_burst_counter, dp_dataConv_rd_burst_counter_reg: std_logic_vector(1 downto 0);
  signal PLB_MRdDBus_reverse : std_logic_vector(PLB_DW-1 downto 0);

  -- signals with dp_ prefix stand for data phase signals
  -- signals with req_ prefix stand for request phase signals

begin

  -- interface to user logic
  BUS_RdData <= rd_fifo_dout;
  BUS_req_full_n <= req_fifo_full_n and wd_fifo_full_n;
  BUS_rsp_nRW <= '0';
  BUS_rsp_empty_n <= rd_fifo_empty_n;

  -- interface to PLB
  M_abort <= '0';
  M_busLock <= '0';
  M_lockErr <= '0';
  M_MSize <= "01";    -- 00:32b dev, 01:64b, 10:128b, 11:256b
  M_size <= "0000" when (burst_mode = '0' or burst_size = "0000") else "1011";    -- single rw or 64 bits burst
  M_type <= "000";    -- memory trans
  M_priority <= "00";
  M_RNW <= not req_nRW;

  M_rdBurst <= '1' when pending_rd_req_burst_mode = '1' and
           (pending_rd_req_burst_size /= "0000" or dp_dataConv_rd_burst_counter /="00") else '0';

  process (PLB_MSSize)
  begin
      M_wrBurst <= '0';
      if (pending_wr_req_burst_mode = '1' and
          (pending_wr_req_burst_size /= "0000" or dp_dataConv_wd_burst_counter /="00")) then
          M_wrBurst <= '1';
      elsif (request = '1' and req_nRW = '1' and pending_write = '0' and
             burst_mode = '1' and burst_size /="0000" and wd_fifo_use_word > burst_size) then
          M_wrBurst <= '1';
      end if;
  end process;

  -- write data mirror section
  process (PLB_MSSize)
  begin
      if (C_PLB_DWIDTH = 64 and PLB_MSSize = "00") then
          conv_mode_comb <= "10"; -- conv 64:32
          conv_counter_comb <= "01";
      elsif (C_PLB_DWIDTH = 128 and PLB_MSSize = "01") then
          conv_mode_comb <= "11"; -- conv 128:64
          conv_counter_comb <= "01";
      elsif (C_PLB_DWIDTH = 128 and PLB_MSSize = "00") then
          conv_mode_comb <= "01"; -- conv 128:32
          conv_counter_comb <= "11";
      else
          conv_mode_comb <= "00"; -- do not need conv
          conv_counter_comb <= "00";
      end if;
  end process;

  process (burst_mode, burst_size, conv_mode_comb, req_address, req_BE)
  begin
    dataConv_last <= '0';
    if (burst_mode = '0' or burst_size = "0000") then 
        if (conv_mode_comb = "00") then -- no conv
            dataConv_last <= '1';
        elsif (conv_mode_comb = "10") then -- 64:32 conv
            if (req_address(29)='1' or req_BE(PLB_BYTE_COUNT-1 downto PLB_BYTE_COUNT/2)=CONV_STD_LOGIC_VECTOR(0,PLB_BYTE_COUNT/2)) then
                dataConv_last <= '1';
            end if;
        elsif (conv_mode_comb = "11") then -- 128:64 conv
            if (req_address(28)='1' or req_BE(PLB_BYTE_COUNT-1 downto PLB_BYTE_COUNT/2)=CONV_STD_LOGIC_VECTOR(0,PLB_BYTE_COUNT/2)) then
                dataConv_last <= '1';
            end if;
        elsif (conv_mode_comb = "01") then -- 128:32 conv
            if (req_address(28 to 29) = "00" and req_BE(PLB_BYTE_COUNT-1 downto PLB_BYTE_COUNT/4)=CONV_STD_LOGIC_VECTOR(0,PLB_BYTE_COUNT*3/4)) then
                dataConv_last <= '1';
            elsif (req_address(28 to 29) = "01" and req_BE(PLB_BYTE_COUNT-1 downto PLB_BYTE_COUNT/2)=CONV_STD_LOGIC_VECTOR(0,PLB_BYTE_COUNT/2)) then
                dataConv_last <= '1';
            elsif (req_address(28 to 29) = "10" and req_BE(PLB_BYTE_COUNT-1 downto PLB_BYTE_COUNT*3/4)=CONV_STD_LOGIC_VECTOR(0,PLB_BYTE_COUNT/4)) then
                dataConv_last <= '1';
            elsif (req_address(28 to 29) = "11") then
                dataConv_last <= '1';
            end if;
        end if;
    end if;
  end process;

  process (PLB_Clk, PLB_Rst)
  begin
    if (PLB_Rst = '1') then
        dp_dataConv_word_addr <= (others => '0');
        dp_dataConv_wd_conv_mode <= (others =>'0');
        dp_dataConv_wd_burst_counter <= (others => '0');
        dp_dataConv_wd_BE <= (others => '0');
        dp_dataConv_last <= '0';
        wr_data_phase <= '0';
    elsif (PLB_Clk'event and PLB_Clk = '1') then
        if (PLB_MAddrAck = '1' and req_nRW = '1') then
            dp_dataConv_wd_BE <= req_BE;
            dp_dataConv_last <= dataConv_last;
        end if;
        if (PLB_MAddrAck = '1' and req_nRW = '1' and 
            (PLB_MWrDAck = '0' or (burst_mode = '1' and burst_size /= "0000"))) then
            wr_data_phase <= '1';
        end if;
        if (PLB_MWrDAck = '1' and wr_data_phase = '1') then
            if ((pending_wr_req_burst_size = "0000" and dp_dataConv_wd_burst_counter = "00") or
            (pending_wr_req_burst_mode = '0')) then
                wr_data_phase <= '0';
            end if;
        end if;
        if (PLB_MAddrAck = '1' and req_nRW = '1' and dp_dataConv_wd_conv_mode = "00") then
            if (PLB_MWrDAck = '0') then
                -- only AddrAck asserted
                dp_dataConv_wd_conv_mode <= conv_mode_comb;
                dp_dataConv_word_addr <= req_address(28 to 29);
                dp_dataConv_wd_burst_counter <= conv_counter_comb;
            else
                -- Xilinx PLB v4.6 support assert addrAck & wrDAck at the same cycle
                if (dataConv_last = '0') then
                    dp_dataConv_wd_conv_mode <= conv_mode_comb;
                end if;
                if (PLB_MSSize = "00") then -- 32 bits slave
                    dp_dataConv_word_addr <= req_address(28 to 29) +1;
                elsif (PLB_MSSize = "01") then -- 64 bits slave
                    dp_dataConv_word_addr <= req_address(28 to 29) +2;
                end if;
                if (conv_mode_comb /= "00") then -- need conv
                    dp_dataConv_wd_burst_counter <= conv_counter_comb -1;
                end if;
            end if;
        end if;
        if (wr_data_phase = '1' and PLB_MWrDAck = '1' and
            ((pending_wr_req_burst_mode = '1' and pending_wr_req_burst_size = "0000" and dp_dataConv_wd_burst_counter = "00") or
             (pending_wr_req_burst_mode = '0' and dp_dataConv_last = '1'))) then
            dp_dataConv_wd_conv_mode <= "00";
        end if;
        if (PLB_MWrDAck = '1' and wr_data_phase = '1') then
            if (dp_PLB_MSSize = "01") then -- 64 bits slave
                dp_dataConv_word_addr <= dp_dataConv_word_addr +2;
            else
                dp_dataConv_word_addr <= dp_dataConv_word_addr +1;
            end if;
            if ((pending_wr_req_burst_mode = '1' and pending_wr_req_burst_size /= "0000") or
                dp_dataConv_wd_burst_counter /= "00") then
                if (dp_dataConv_wd_burst_counter = "00") then
                    if (dp_dataConv_wd_conv_mode = "01") then -- 128/32
                        dp_dataConv_wd_burst_counter <= "11";
                    elsif (dp_dataConv_wd_conv_mode(1) = '1') then  -- 64/32 or 128/64
                        dp_dataConv_wd_burst_counter <= "01";
                    end if;
                else
                    dp_dataConv_wd_burst_counter <= dp_dataConv_wd_burst_counter -1;
                end if;
            end if;
        end if;
    end if;
  end process;

  process(PLB_MWrDAck, wr_data_phase, dp_dataConv_wd_burst_counter, burst_mode, conv_counter_comb, conv_mode_comb, req_BE)
  begin
      wd_fifo_pop <= '0';
      if (PLB_MWrDAck = '1') then
          if (wr_data_phase = '1') then
              if ((pending_wr_req_burst_mode = '1' and dp_dataConv_wd_burst_counter = "00") or
                  (dp_dataConv_wd_conv_mode /= "00" and dp_dataConv_last = '1') or
                   dp_dataConv_wd_conv_mode = "00" )then
                  wd_fifo_pop <= '1';
              end if;
          else
              -- got addrAck and wrDAck at the same cycle
              if (burst_mode = '1' and burst_size /= "0000" and conv_counter_comb = "00") then
                  wd_fifo_pop <= '1';
              elsif ((burst_mode = '0' or burst_size = "0000") and dataConv_last = '1') then
                  wd_fifo_pop <= '1';
              end if;
          end if;
      end if;
  end process;

  process(wd_fifo_dout, wr_data_phase, req_address, dp_dataConv_wd_conv_mode, dp_dataConv_word_addr)
  begin
      wd_fifo_dout_mirror <= wd_fifo_dout;
      if (wr_data_phase = '0') then -- we do not know slave bus width, perform default convert
          if (C_PLB_DWIDTH = 32) then
              wd_fifo_dout_mirror <= wd_fifo_dout;
          elsif (C_PLB_DWIDTH = 64) then
              if (req_address(29) = '0') then
                  wd_fifo_dout_mirror <= wd_fifo_dout;
              else
                  wd_fifo_dout_mirror(PLB_DW/2-1 downto 0) <= wd_fifo_dout(PLB_DW-1 downto PLB_DW/2);
                  wd_fifo_dout_mirror(PLB_DW-1 downto PLB_DW/2) <= wd_fifo_dout(PLB_DW-1 downto PLB_DW/2);
              end if;
          elsif (C_PLB_DWIDTH = 128) then
              case req_address(28 to 29) is
              when "00" =>
                  wd_fifo_dout_mirror <= wd_fifo_dout;
              when "01" =>
                  wd_fifo_dout_mirror(C_PLB_DWIDTH/4-1 downto 0) <= wd_fifo_dout(C_PLB_DWIDTH/2-1 downto C_PLB_DWIDTH/4);
                  wd_fifo_dout_mirror(C_PLB_DWIDTH-1 downto C_PLB_DWIDTH/4) <= wd_fifo_dout(C_PLB_DWIDTH-1 downto C_PLB_DWIDTH/4);
              when "10" =>
                  wd_fifo_dout_mirror(C_PLB_DWIDTH/2-1 downto 0) <= wd_fifo_dout(C_PLB_DWIDTH-1 downto C_PLB_DWIDTH/2);
                  wd_fifo_dout_mirror(C_PLB_DWIDTH-1 downto C_PLB_DWIDTH/2) <= wd_fifo_dout(C_PLB_DWIDTH-1 downto C_PLB_DWIDTH/2);
              when "11" =>
                  wd_fifo_dout_mirror(C_PLB_DWIDTH/4-1 downto 0) <= wd_fifo_dout(C_PLB_DWIDTH-1 downto C_PLB_DWIDTH*3/4);
                  wd_fifo_dout_mirror(C_PLB_DWIDTH/2-1 downto C_PLB_DWIDTH/4) <= wd_fifo_dout(C_PLB_DWIDTH-1 downto C_PLB_DWIDTH*3/4);
                  wd_fifo_dout_mirror(C_PLB_DWIDTH*3/4-1 downto C_PLB_DWIDTH/2) <= wd_fifo_dout(C_PLB_DWIDTH-1 downto C_PLB_DWIDTH*3/4);
                  wd_fifo_dout_mirror(C_PLB_DWIDTH-1 downto C_PLB_DWIDTH*3/4) <= wd_fifo_dout(C_PLB_DWIDTH-1 downto C_PLB_DWIDTH*3/4);
              when others => null;
              end case;
          end if;
      else -- in data phase
          wd_fifo_dout_mirror <= wd_fifo_dout;
          if ((dp_dataConv_wd_conv_mode = "10" and dp_dataConv_word_addr(0) = '1') or
              (dp_dataConv_wd_conv_mode = "11" and dp_dataConv_word_addr(1) = '1')) then -- conv 64:32 or 128:64
              wd_fifo_dout_mirror(C_PLB_DWIDTH/2-1 downto 0) <= wd_fifo_dout(C_PLB_DWIDTH-1 downto C_PLB_DWIDTH/2);
              wd_fifo_dout_mirror(C_PLB_DWIDTH-1 downto C_PLB_DWIDTH/2) <= wd_fifo_dout(C_PLB_DWIDTH-1 downto C_PLB_DWIDTH/2);
          elsif (dp_dataConv_wd_conv_mode = "01") then -- conv 128:32
              case dp_dataConv_word_addr is
              when "00" =>
                  wd_fifo_dout_mirror <= wd_fifo_dout;
              when "01" =>
                  wd_fifo_dout_mirror(C_PLB_DWIDTH/4-1 downto 0) <= wd_fifo_dout(C_PLB_DWIDTH/2-1 downto C_PLB_DWIDTH/4);
              when "10" =>
                  wd_fifo_dout_mirror(C_PLB_DWIDTH/4-1 downto 0) <= wd_fifo_dout(C_PLB_DWIDTH*3/4-1 downto C_PLB_DWIDTH/2);
              when "11" =>
                  wd_fifo_dout_mirror(C_PLB_DWIDTH/4-1 downto 0) <= wd_fifo_dout(C_PLB_DWIDTH-1 downto C_PLB_DWIDTH*3/4);
              when others => null;
              end case;
          end if;
      end if;
  end process;

  process(wd_fifo_dout_mirror)
  variable i: integer;
  begin
    for i in 0 to C_PLB_DWIDTH-1 loop
        M_wrDBus(i) <= wd_fifo_dout_mirror(i);
    end loop;
  end process;

  process (request, req_nRW, pending_read, burst_mode, rd_fifo_full_n, rd_fifo_use_word, 
  pending_write, wd_fifo_empty_n, wd_fifo_use_word, burst_size)
  begin
      M_request <= '0';
      if (request = '1') then
          if (req_nRW = '0' and pending_read = '0') then -- read request
              if ((burst_mode = '0' or burst_size = "0000") and rd_fifo_full_n = '1') then
                  M_request <= '1';
              elsif (rd_fifo_use_word(4) = '0') then -- 16 words slots available
                  M_request <= '1';
              end if;
          elsif (req_nRW = '1' and pending_write = '0') then -- write request
              if ((burst_mode = '0' or burst_size = "0000") and wd_fifo_empty_n = '1') then
                  M_request <= '1';
              elsif (wd_fifo_use_word > burst_size) then
                  M_request <= '1';
              end if;
          end if;
      end if;
  end process;

  M_ABus(0 to C_PLB_AWIDTH - 1) <= req_address;

  process(req_nRW, burst_mode, burst_size, req_BE)
  variable i:integer;
  begin
    M_BE <= (others => '0');
    if (burst_mode = '1') then
        if (burst_size = "0000") then
            M_BE <= (others => '1'); -- first single,then burst 16
        else
            M_BE(0 to 3) <= burst_size; -- fixed length burst
        end if;
    elsif (req_nRW = '0') then
        M_BE <= (others => '1');
    else
        for i in 0 to PLB_BYTE_COUNT-1 loop
            M_BE(i) <= req_BE(i);
        end loop;
    end if;
  end process;
  
  -- user req FIFO, for both read request and write request
  U_req_nfa_initials_buckets_if_fifo: component nfa_initials_buckets_if_ap_fifo 
  generic map(
    DATA_WIDTH => REQ_FIFO_WIDTH,
    ADDR_WIDTH => FIFO_ADDR_WIDTH,
    DEPTH => FIFO_DEPTH)
  port map(
    clk        => PLB_Clk,
    reset      => PLB_Rst,
    if_empty_n => req_fifo_empty_n,
    if_read    => req_fifo_pop,
    if_dout    => req_fifo_dout,
    if_full_n  => req_fifo_full_n,
    if_write   => req_fifo_push,
    if_din     => req_fifo_din
  );
  req_fifo_push <= BUS_req_push and not req_burst_write;
  req_fifo_din <= BUS_req_nRW & BUS_req_BE & BUS_address & BUS_size;
  req_fifo_dout_req_size <= req_fifo_dout(31 downto 0) -1;

  process (PLB_Clk, PLB_Rst)
  begin
    if (PLB_Rst = '1') then
        req_burst_write <= '0';
        req_burst_write_counter <= (others => '0');
    elsif (PLB_Clk'event and PLB_Clk = '1') then
        if (req_fifo_push = '1' and BUS_req_nRW = '1' and BUS_size(31 downto 1) /= "0000000000000000000000000000000") then
            req_burst_write <= '1';
            req_burst_write_counter <= BUS_size - 1;
        end if;
        if (BUS_req_push = '1' and BUS_req_nRW = '1' and req_burst_write = '1') then
            req_burst_write_counter <= req_burst_write_counter -1;
        end if;
        if (BUS_req_push = '1' and BUS_req_nRW = '1' and req_burst_write_counter = X"00000001") then-- last burst write data
            req_burst_write <= '0';
        end if;
    end if;
  end process;

  process (PLB_Clk, PLB_Rst)
  begin
    if (PLB_Rst = '1') then
        request <= '0';
        req_size <= (others => '0');
        req_nRW <= '0';
        req_address(0 to C_PLB_AWIDTH - 1) <= (others => '0');
        burst_mode <= '0';
        burst_size <= (others => '0');
        req_fifo_pop <= '0';
    elsif (PLB_Clk'event and PLB_Clk = '1') then
        req_fifo_pop <= '0';
        if ((request = '0' and req_fifo_empty_n = '1') or PLB_MAddrAck = '1') then
            if (PLB_MAddrAck = '1' and (burst_mode = '0' or burst_size ="0000") and dataConv_last = '0') then
                request <= '1';
                if (conv_mode_comb(1) = '1') then -- 2:1 conv
                    req_BE(PLB_BYTE_COUNT/2-1 downto 0) <= (others => '0');
                else  -- 128:32
                    if (req_address(28 to 29) = "00") then
                        req_BE(PLB_BYTE_COUNT/4-1 downto 0) <= (others => '0');
                    elsif (req_address(28 to 29) = "01") then
                        req_BE(PLB_BYTE_COUNT/2-1 downto PLB_BYTE_COUNT/4) <= (others => '0');
                    elsif (req_address(28 to 29) = "10") then
                        req_BE(PLB_BYTE_COUNT*3/4-1 downto PLB_BYTE_COUNT/2) <= (others => '0');
                    end if;
                end if;
                if (PLB_MSSize = "00") then -- 32 bits slave
                    req_address <= req_address + 4;
                elsif (PLB_MSSize = "01") then -- 64 slave
                    req_address <= req_address + 8;
                end if;-- 128 bits slave does not need conversion cycle
            elsif (PLB_MAddrAck = '1' and burst_mode = '1' and burst_last = '0') then
                request <= '1';    -- req next burst section, this will be pending until previous burst finished
                req_size(0 to 27) <= req_size(0 to 27) - 1; 
                req_address(0 to C_PLB_AWIDTH - PLB_ADDR_SHIFT - 1) <= req_address(0 to C_PLB_AWIDTH -PLB_ADDR_SHIFT -1) + burst_size +1;
                req_address(C_PLB_AWIDTH-PLB_ADDR_SHIFT to C_PLB_AWIDTH-1) <= (others => '0');
                -- low bits of addr must be reset for possible data_conv modifications of 10 lines above

                burst_mode <= '1';
                burst_size <= "1111"; -- burst 16 words
            else
                if (req_fifo_empty_n = '1') then
                    req_fifo_pop <= '1';
                end if;
                request <= req_fifo_empty_n;    -- fetch next user_req, may be a vaild req or a null req
                req_size(0 to 27) <= req_fifo_dout_req_size(31 downto 4); --remaining burst transfer except current one
                req_nRW <= req_fifo_dout(REQ_FIFO_WIDTH-1);
                req_BE <= req_fifo_dout(REQ_FIFO_WIDTH-2 downto 64);
                req_address <= req_fifo_dout(63 downto 32); 
                if (req_fifo_dout(REQ_FIFO_WIDTH-1) = '0') then -- read request
                    req_address(C_PLB_AWIDTH-PLB_ADDR_SHIFT to C_PLB_AWIDTH-1) <= (others => '0'); 
                end if;

                -- long burst request will be split to 1stReq: 1-16 words, all next req: 16 words
                if (req_fifo_dout_req_size /= X"00000000") then  -- more than 1 word, burst
                  burst_mode <= req_fifo_empty_n;    -- fetched req may be null req
                  -- req of burst 17 will be single + burst 16, please check burst_size also
                else
                  burst_mode <= '0';
                end if;
                burst_size(3 downto 0) <= req_fifo_dout_req_size(3 downto 0);-- 0:single, 1-15: burst 2-16words 
            end if;
        end if;
    end if;
  end process;

  process (PLB_Clk, PLB_Rst)
  begin
    if (PLB_Rst = '1') then
        pending_read <= '0';
        pending_write <= '0';
        dp_PLB_MSSize <= (others => '0');
    elsif (PLB_Clk'event and PLB_Clk = '1') then
        if (PLB_MRdDAck = '1' and 
        ((pending_rd_req_burst_mode = '1' and pending_rd_req_burst_size = "0000" and dp_dataConv_rd_burst_counter = "00") or
         (pending_rd_req_burst_mode = '0'))) then
            pending_read <= '0';
        elsif (PLB_MAddrAck = '1' and req_nRW='0') then
            pending_read <= '1';
        end if;
        if (PLB_MWrDAck = '1' and wr_data_phase = '1' and
        ((pending_wr_req_burst_mode = '1' and pending_wr_req_burst_size = "0000" and dp_dataConv_wd_burst_counter = "00") or
            pending_wr_req_burst_mode = '0')) then
            pending_write <= '0';
        elsif (PLB_MAddrAck = '1' and req_nRW='1' and 
               (PLB_MWrDAck = '0' or burst_size /= "0000")) then
            pending_write <= '1';
        end if;    
        if (PLB_MAddrAck = '1') then 
            dp_PLB_MSSize <= PLB_MSSize;
        end if;
    end if;
  end process;

  process(req_size)
  begin
      if (req_size(0 to 27) = "000000000000000000000000000") then
        burst_last <= '1'; -- one request is ok
      else
        burst_last <= '0';
      end if;
  end process;

  -- user write data FIFO, for data of bus write request
  U_wd_nfa_initials_buckets_if_fifo: component nfa_initials_buckets_if_ap_fifo_uw 
  generic map(
    DATA_WIDTH => PLB_DW,
    ADDR_WIDTH => FIFO_ADDR_WIDTH,
    DEPTH => FIFO_DEPTH)
  port map(
    clk     => PLB_Clk,
    reset     => PLB_Rst,
    if_empty_n     => wd_fifo_empty_n,
    if_read     => wd_fifo_pop,
    if_dout     => wd_fifo_dout,
    if_full_n     => wd_fifo_full_n,
    if_write     => wd_fifo_push,
    if_din     => wd_fifo_din,
    use_word    => wd_fifo_use_word
  );
  wd_fifo_push <= BUS_req_push and BUS_req_nRW;
  wd_fifo_din <= BUS_WrData;

  -- returned bus read data fifo
  U_rd_nfa_initials_buckets_if_fifo: component nfa_initials_buckets_if_ap_fifo_uw 
  generic map(
    DATA_WIDTH => PLB_DW,
    ADDR_WIDTH => FIFO_ADDR_WIDTH,
    DEPTH => FIFO_DEPTH)
  port map(
    clk     => PLB_Clk,
    reset     => PLB_Rst,
    if_empty_n     => rd_fifo_empty_n,
    if_read     => rd_fifo_pop,
    if_dout     => rd_fifo_dout,
    if_full_n     => rd_fifo_full_n,
    if_write     => rd_fifo_push,
    if_din     => rd_fifo_din,
    use_word    => rd_fifo_use_word
  );

  process (PLB_Clk, PLB_Rst)
  begin
    if (PLB_Rst = '1') then
        dp_dataConv_rd_conv_mode <= (others =>'0');
        dp_dataConv_rd_burst_counter <= (others => '0');
        dp_dataConv_rd_burst_counter_reg <= (others => '0');
        PLB_MRdDAck_reg <= '0';
    elsif (PLB_Clk'event and PLB_Clk = '1') then
        if (PLB_MAddrAck = '1' and req_nRW = '0' and dp_dataConv_rd_conv_mode = "00") then
            dp_dataConv_rd_conv_mode <= conv_mode_comb;
            dp_dataConv_rd_burst_counter <= conv_counter_comb;
        end if;
        if (PLB_MRdDAck = '1' and
            ((pending_rd_req_burst_mode = '1' and (pending_rd_req_burst_size = "0000" and dp_dataConv_rd_burst_counter = "00")) or
             (pending_rd_req_burst_mode = '0' and dp_dataConv_rd_burst_counter = "00")))then
            dp_dataConv_rd_conv_mode <= "00";
        end if;
        if (PLB_MRdDAck = '1' and
            ((pending_rd_req_burst_mode = '1' and (pending_rd_req_burst_size /= "0000" or dp_dataConv_rd_burst_counter /= "00")) or
             (pending_rd_req_burst_mode = '0' and dp_dataConv_rd_burst_counter /= "00")))then
            if (dp_dataConv_rd_burst_counter = "00") then
                if (dp_dataConv_rd_conv_mode = "01") then -- 128/32
                    dp_dataConv_rd_burst_counter <= "11";
                elsif (dp_dataConv_rd_conv_mode(1) = '1') then  -- 64/32 or 128/64
                    dp_dataConv_rd_burst_counter <= "01";
                end if;
            else
                dp_dataConv_rd_burst_counter <= dp_dataConv_rd_burst_counter -1;
            end if;
        end if;
        dp_dataConv_rd_burst_counter_reg <= dp_dataConv_rd_burst_counter;
        PLB_MRdDAck_reg <= PLB_MRdDAck;
    end if;
  end process;

  rd_fifo_push <= '1' when PLB_MRdDAck_reg = '1' and dp_dataConv_rd_burst_counter_reg = "00" else '0';

  process(PLB_MRdDBus)
  variable i: integer;
  begin
    -- change to little endian
    for i in 0 to C_PLB_DWIDTH-1 loop
        PLB_MRdDBus_reverse(i) <= PLB_MRdDBus(i);
    end loop;
  end process;

  process(PLB_Clk, PLB_Rst)
  begin
    if (PLB_Rst = '1') then
        rd_fifo_din <= (others => '0');
    elsif (PLB_Clk'event and PLB_Clk = '1') then
        if (PLB_MRdDAck = '1') then
            case dp_dataConv_rd_conv_mode is
            when "00" => rd_fifo_din <= PLB_MRdDBus_reverse;
            when "10" | "11" => 
                if (dp_dataConv_rd_burst_counter = "00") then
                    rd_fifo_din(PLB_DW-1 downto PLB_DW/2) <= PLB_MRdDBus_reverse(PLB_DW/2-1 downto 0);
                else
                    rd_fifo_din(PLB_DW/2-1 downto 0) <= PLB_MRdDBus_reverse(PLB_DW/2-1 downto 0);
                end if;
            when "01" => 
                case dp_dataConv_rd_burst_counter is
                when "00" =>
                    rd_fifo_din(PLB_DW-1 downto PLB_DW*3/4) <= PLB_MRdDBus_reverse(PLB_DW/4-1 downto 0);
                when "01" =>
                    rd_fifo_din(PLB_DW*3/4-1 downto PLB_DW/2) <= PLB_MRdDBus_reverse(PLB_DW/4-1 downto 0);
                when "10" =>
                    rd_fifo_din(PLB_DW/2-1 downto PLB_DW/4) <= PLB_MRdDBus_reverse(PLB_DW/4-1 downto 0);
                when "11" =>
                    rd_fifo_din(PLB_DW/4-1 downto 0) <= PLB_MRdDBus_reverse(PLB_DW/4-1 downto 0);
                when others => null;
                end case;
            when others => null;
            end case;
        end if;
    end if;
  end process;

  rd_fifo_pop <= BUS_rsp_pop;

  pending_read_req_p: process (PLB_Clk, PLB_Rst)
  begin
    if (PLB_Rst = '1') then
        pending_rd_req_burst_mode <= '0';
        pending_rd_req_burst_size <= (others => '0');
    elsif (PLB_Clk'event and PLB_Clk = '1') then
        if (PLB_MAddrAck = '1' and req_nRW = '0') then
            if (burst_mode = '1' and burst_size /= "0000") then
                pending_rd_req_burst_mode <= burst_mode;
            end if;
            pending_rd_req_burst_size <= burst_size;
        elsif (PLB_MRdDAck = '1' and pending_rd_req_burst_mode = '1') then
            if (dp_dataConv_rd_burst_counter = "00") then
                pending_rd_req_burst_size <= pending_rd_req_burst_size - 1;
                if (pending_rd_req_burst_size = "0000") then
                    pending_rd_req_burst_mode <= '0';
                end if;
            end if;
        end if;
    end if;
  end process;

  pending_write_req_p: process (PLB_Clk, PLB_Rst)
  begin
    if (PLB_Rst = '1') then
        pending_wr_req_burst_mode <= '0';
        pending_wr_req_burst_size <= (others => '0');
    elsif (PLB_Clk'event and PLB_Clk = '1') then
        if (PLB_MAddrAck = '1' and req_nRW = '1') then
            if (burst_mode = '1' and burst_size /= "0000") then
                pending_wr_req_burst_mode <= '1';
            end if;
            pending_wr_req_burst_size <= burst_size;
            if (PLB_MWrDAck = '1') then
                if (conv_counter_comb = "00") then
                    pending_wr_req_burst_size <= burst_size -1;
                else
                    pending_wr_req_burst_size <= burst_size;
                end if;
            end if;
        elsif (PLB_MWrDAck = '1' and pending_wr_req_burst_mode = '1') then
            if (dp_dataConv_wd_burst_counter = "00") then
                pending_wr_req_burst_size <= pending_wr_req_burst_size - 1;
                if (pending_wr_req_burst_size = "0000") then
                    pending_wr_req_burst_mode <= '0';
                end if;
            end if;
        end if;
    end if;
  end process;

end IMP;

