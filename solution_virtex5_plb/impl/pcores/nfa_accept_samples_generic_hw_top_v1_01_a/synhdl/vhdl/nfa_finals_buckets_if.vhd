-- ==============================================================
-- File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
-- Version: 2014.1
-- Copyright (C) 2014 Xilinx Inc. All rights reserved.
-- 
-- ==============================================================

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

entity nfa_finals_buckets_if is
  generic
  (
    C_PLB_AWIDTH                  : integer               := 32;
    C_PLB_DWIDTH                  : integer               := 64;
    PLB_ADDR_SHIFT                 : integer              := 3;
    USER_DATA_WIDTH                : integer              := 32;
    USER_DATA_WIDTH_2N             : integer              := 32;
    USER_ADDR_SHIFT                : integer              := 2;  -- log2(byte_count_of_data_width)
    REMOTE_DESTINATION_ADDRESS     : std_logic_vector(0 to 31):= X"00000000"
  );
  port
  (
    -- Bus protocol ports, do not add to or delete
    MPLB_Clk                        : in  std_logic;
    MPLB_Rst                        : in  std_logic;

    M_request                      : out std_logic;
    M_priority                     : out std_logic_vector(0 to 1);
    M_busLock                      : out std_logic;
    M_RNW                          : out std_logic;
    M_BE                           : out std_logic_vector(0 to C_PLB_DWIDTH/8-1);
    M_MSize                        : out std_logic_vector(0 to 1);
    M_size                         : out std_logic_vector(0 to 3);
    M_type                         : out std_logic_vector(0 to 2);
    M_TAttribute                   : out std_logic_vector(0 to 15);
    M_lockErr                      : out std_logic;
    M_abort                        : out std_logic;
    M_ABus                         : out std_logic_vector(0 to C_PLB_AWIDTH-1);
    M_UABus                        : out std_logic_vector(0 to 31);
    M_wrDBus                       : out std_logic_vector(0 to C_PLB_DWIDTH-1);
    M_wrBurst                      : out std_logic;
    M_rdBurst                      : out std_logic;
    PLB_MAddrAck                   : in  std_logic;
    PLB_MSSize                     : in  std_logic_vector(0 to 1);
    PLB_MRearbitrate               : in  std_logic;
    PLB_MTimeout                   : in  std_logic;
    PLB_MBusy                      : in  std_logic;
    PLB_MRdErr                     : in  std_logic;
    PLB_MWrErr                     : in  std_logic;
    PLB_MIRQ                       : in  std_logic;
    PLB_MRdDBus                    : in  std_logic_vector(0 to (C_PLB_DWIDTH-1));
    PLB_MRdWdAddr                  : in  std_logic_vector(0 to 3);
    PLB_MRdDAck                    : in  std_logic;
    PLB_MRdBTerm                   : in  std_logic;
    PLB_MWrDAck                    : in  std_logic;
    PLB_MWrBTerm                   : in  std_logic;

    -- signals from user logic
    USER_RdData     : out std_logic_vector(USER_DATA_WIDTH - 1 downto 0);    -- Bus read return data to user_logic
    USER_WrData     : in std_logic_vector(USER_DATA_WIDTH - 1 downto 0);    -- Bus write data
    USER_address     : in std_logic_vector(31 downto 0);        -- word offset from BASE_ADDRESS 
    USER_size         : in std_logic_vector(31 downto 0);        -- burst size of word
    USER_req_nRW     : in std_logic;                    -- req type 0: Read, 1: write
    USER_req_full_n     : out std_logic;                -- req Fifo full
    USER_req_push     : in std_logic;                    -- req Fifo push (new request in)
    USER_rsp_empty_n     : out std_logic;                -- return data FIFO empty
    USER_rsp_pop     : in std_logic                    -- return data FIFO pop
  );

  attribute SIGIS : string;
  attribute SIGIS of MPLB_Clk       : signal is "Clk";
  attribute SIGIS of MPLB_Rst       : signal is "Rst";

end entity;

------------------------------------------------------------------------------
-- Architecture section
------------------------------------------------------------------------------

architecture IMP of nfa_finals_buckets_if is

component nfa_finals_buckets_if_ap_fifo is 
    generic (
        DATA_WIDTH : integer := 32;
        ADDR_WIDTH : integer := 4;
        DEPTH : integer := 16);
    port (
        clk : IN STD_LOGIC;
        reset : IN STD_LOGIC;
        if_empty_n : OUT STD_LOGIC;
        if_read : IN STD_LOGIC;
        if_dout : OUT STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0);
        if_full_n : OUT STD_LOGIC;
        if_write : IN STD_LOGIC;
        if_din : IN STD_LOGIC_VECTOR(DATA_WIDTH - 1 downto 0) );
end component;

component nfa_finals_buckets_if_plb_master_if is
  generic (
    C_PLB_AWIDTH                   : integer              := 32;
    C_PLB_DWIDTH                   : integer              := 64;
    PLB_ADDR_SHIFT                 : integer              := 3);
  port (
    -- Bus protocol ports, do not add to or delete
    PLB_Clk                        : in  std_logic;
    PLB_Rst                        : in  std_logic;

    M_abort                        : out std_logic;
    M_ABus                         : out std_logic_vector(0 to C_PLB_AWIDTH-1);
    M_BE                           : out std_logic_vector(0 to C_PLB_DWIDTH/8-1);
    M_busLock                      : out std_logic;
    M_lockErr                      : out std_logic;
    M_MSize                        : out std_logic_vector(0 to 1);
    M_priority                     : out std_logic_vector(0 to 1);
    M_rdBurst                      : out std_logic;
    M_request                      : out std_logic;
    M_RNW                          : out std_logic;
    M_size                         : out std_logic_vector(0 to 3);
    M_type                         : out std_logic_vector(0 to 2);
    M_wrBurst                      : out std_logic;
    M_wrDBus                       : out std_logic_vector(0 to C_PLB_DWIDTH-1);

    PLB_MBusy                      : in  std_logic;
    PLB_MWrBTerm                   : in  std_logic;
    PLB_MWrDAck                    : in  std_logic;
    PLB_MAddrAck                   : in  std_logic;
    PLB_MRdBTerm                   : in  std_logic;
    PLB_MRdDAck                    : in  std_logic;
    PLB_MRdDBus                    : in  std_logic_vector(0 to (C_PLB_DWIDTH-1));
    PLB_MRdWdAddr                  : in  std_logic_vector(0 to 3);
    PLB_MRearbitrate               : in  std_logic;
    PLB_MSSize                     : in  std_logic_vector(0 to 1);

    -- signals from user logic
    BUS_RdData     : out std_logic_vector(C_PLB_DWIDTH-1 downto 0);            -- Bus read return data to user_logic
    BUS_WrData     : in std_logic_vector(C_PLB_DWIDTH-1 downto 0);        -- Bus write data
    BUS_address     : in std_logic_vector(31 downto 0);        -- word offset from BASE_ADDRESS 
    BUS_size         : in std_logic_vector(31 downto 0);        -- burst size of word
    BUS_req_nRW     : in std_logic;                    -- req type 0: Read, 1: write
    BUS_req_BE      : in std_logic_vector(C_PLB_DWIDTH/8 -1 downto 0);         -- Bus write data byte enable
    BUS_req_full_n     : out std_logic;                -- req Fifo full
    BUS_req_push     : in std_logic;                    -- req Fifo push (new request in)
    BUS_rsp_nRW     : out std_logic;                -- return data FIFO rsp type
    BUS_rsp_empty_n     : out std_logic;                -- return data FIFO empty
    BUS_rsp_pop     : in std_logic                    -- return data FIFO pop
  );
end component;
  -- type state_type is (IDLE, );
  -- signal cs, ns : st_type;

  constant PLB_BW : integer := C_PLB_DWIDTH;
  constant PLB_BYTE_COUNT : integer := C_PLB_DWIDTH/8;
  constant USER_DATA_BYTE_COUNT : integer := USER_DATA_WIDTH_2N/8;
  constant REQ_FIFO_DATA_WIDTH : integer := 1 + 32 + 32 + USER_DATA_WIDTH_2N; -- nRW + addr + size + wr_data
  constant REQ_FIFO_ADDR_WIDTH : integer := 5;
  constant REQ_FIFO_DEPTH : integer := 32;

  constant ALIGN_DATA_WIDTH : integer := USER_DATA_WIDTH_2N + PLB_BW;
  constant ALIGN_DATA_BE_WIDTH : integer := (USER_DATA_WIDTH_2N + PLB_BW)/8;

  signal user_phy_address : STD_LOGIC_VECTOR(31 downto 0);
  -- request FIFO
  signal req_fifo_empty_n : STD_LOGIC;
  signal req_fifo_pop : STD_LOGIC;
  signal req_fifo_dout : STD_LOGIC_VECTOR(REQ_FIFO_DATA_WIDTH - 1 downto 0);
  signal req_fifo_full_n : STD_LOGIC;
  signal req_fifo_push : STD_LOGIC;
  signal req_fifo_din : STD_LOGIC_VECTOR(REQ_FIFO_DATA_WIDTH - 1 downto 0);

  signal user_WrData_2N : STD_LOGIC_VECTOR(USER_DATA_WIDTH_2N-1 downto 0);

  signal req_fifo_dout_req_nRW : STD_LOGIC;
  signal req_fifo_dout_req_address : STD_LOGIC_VECTOR(31 downto 0);
  signal req_fifo_dout_req_size, req_fifo_dout_req_size_normalize : STD_LOGIC_VECTOR(31 downto 0);

  -- internal request information
  signal req_nRW : STD_LOGIC;
  signal req_address : STD_LOGIC_VECTOR(31 downto 0);
  signal req_size, burst_size : STD_LOGIC_VECTOR(31 downto 0);
  signal req_size_user : STD_LOGIC_VECTOR(31 downto 0);
  signal req_BE : STD_LOGIC_VECTOR(PLB_BYTE_COUNT-1 downto 0);
  signal req_WrData : STD_LOGIC_VECTOR(ALIGN_DATA_WIDTH -1 downto 0);
  signal req_WrData_BE : STD_LOGIC_VECTOR(ALIGN_DATA_BE_WIDTH -1 downto 0);
  signal req_WrData_byte_p : STD_LOGIC_VECTOR(PLB_ADDR_SHIFT-1 downto 0);
  signal req_valid, req_SOP, req_EOP_user, req_EOP : STD_LOGIC;
  signal req_burst_write_counter : STD_LOGIC_VECTOR(31 downto 0);
  signal req_burst_mode, req_last_burst: STD_LOGIC;
  
  -- interface to PLB_master_if module
  signal PLB_master_if_req_full_n : STD_LOGIC;
  signal PLB_master_if_req_push : STD_LOGIC;
  signal PLB_master_if_dataout : STD_LOGIC_VECTOR(PLB_BW-1 downto 0);

  signal PLB_master_if_rsp_nRW : STD_LOGIC;
  signal PLB_master_if_rsp_empty_n : STD_LOGIC;
  signal PLB_master_if_rsp_pop : STD_LOGIC;

  signal USER_size_local: STD_LOGIC_VECTOR(31 downto 0);

  -- rsp FIFO 
  constant RSP_FIFO_DATA_WIDTH : integer := PLB_ADDR_SHIFT + 32; -- addr + size 
  constant RSP_FIFO_ADDR_WIDTH : integer := 6;
  constant RSP_FIFO_DEPTH : integer := 64;

  signal rsp_fifo_empty_n : STD_LOGIC;
  signal rsp_fifo_pop : STD_LOGIC;
  signal rsp_fifo_dout : STD_LOGIC_VECTOR(RSP_FIFO_DATA_WIDTH -1 downto 0);
  signal rsp_fifo_full_n : STD_LOGIC;
  signal rsp_fifo_push : STD_LOGIC;
  signal rsp_fifo_din : STD_LOGIC_VECTOR(RSP_FIFO_DATA_WIDTH -1 downto 0);

  signal rsp_valid, rsp_SOP : STD_LOGIC;
  signal rsp_addr : STD_LOGIC_VECTOR(PLB_ADDR_SHIFT-1 downto 0);
  signal rsp_size : STD_LOGIC_VECTOR(31 downto 0);

  signal rsp_rd_data : STD_LOGIC_VECTOR(ALIGN_DATA_WIDTH -1 downto 0);
  signal rsp_rd_data_byte_count : STD_LOGIC_VECTOR(4 downto 0);

  -- rd data user FIFO 
  signal rd_data_user_fifo_empty_n : STD_LOGIC;
  signal rd_data_user_fifo_pop : STD_LOGIC;
  signal rd_data_user_fifo_dout : STD_LOGIC_VECTOR(USER_DATA_WIDTH -1 downto 0);
  signal rd_data_user_fifo_full_n : STD_LOGIC;
  signal rd_data_user_fifo_push : STD_LOGIC;
  signal rd_data_user_fifo_din : STD_LOGIC_VECTOR(USER_DATA_WIDTH -1 downto 0);
  signal rd_data_user_fifo_din_2N : STD_LOGIC_VECTOR(USER_DATA_WIDTH_2N -1 downto 0);
  signal BE_ALL_ONE : STD_LOGIC_VECTOR(PLB_BYTE_COUNT -1 downto 0);

begin

  BE_ALL_ONE <= (others => '1');
  M_UABus <= (others => '0');
  M_TAttribute <= (others => '0');

  -- interface to user logic
  user_phy_address(31 downto USER_ADDR_SHIFT) <= REMOTE_DESTINATION_ADDRESS(0 to C_PLB_AWIDTH - USER_ADDR_SHIFT -1) + USER_address(31 -USER_ADDR_SHIFT downto 0);
  user_phy_address(USER_ADDR_SHIFT-1 downto 0) <= REMOTE_DESTINATION_ADDRESS(C_PLB_AWIDTH - USER_ADDR_SHIFT to C_PLB_AWIDTH -1);
  USER_size_local <= X"00000001" when conv_integer(USER_size(31 downto 1)) = 0 else USER_size;
  USER_req_full_n <= req_fifo_full_n;

  process(USER_WrData)
  variable i: integer;
  begin
    user_WrData_2N <= (others=> '0');
    for i in 0 to USER_WrData'length -1 loop
        user_WrData_2N (USER_DATA_WIDTH_2N-1 -i) <= USER_WrData(i);
    end loop;
  end process;

  req_fifo_din(REQ_FIFO_DATA_WIDTH-1) <= USER_req_nRW;
  req_fifo_din(REQ_FIFO_DATA_WIDTH-1-1 downto REQ_FIFO_DATA_WIDTH -1-32) <= user_phy_address;
  req_fifo_din(REQ_FIFO_DATA_WIDTH-1-32-1 downto REQ_FIFO_DATA_WIDTH -1-32-32) <= USER_size_local;
  req_fifo_din(USER_DATA_WIDTH_2N -1 downto 0) <= user_WrData_2N(USER_DATA_WIDTH_2N-1 downto 0);
  req_fifo_push <= USER_req_push;

  U_nfa_finals_buckets_if_req_fifo: component nfa_finals_buckets_if_ap_fifo 
  generic map(
    DATA_WIDTH => REQ_FIFO_DATA_WIDTH,
    ADDR_WIDTH => REQ_FIFO_ADDR_WIDTH,
    DEPTH => REQ_FIFO_DEPTH)
  port map(
    clk => MPLB_Clk,
    reset => MPLB_Rst,
    if_empty_n => req_fifo_empty_n,
    if_read => req_fifo_pop,
    if_dout => req_fifo_dout,
    if_full_n => req_fifo_full_n,
    if_write => req_fifo_push,
    if_din => req_fifo_din
  );
  req_fifo_dout_req_nRW <= req_fifo_dout(REQ_FIFO_DATA_WIDTH -1);
  req_fifo_dout_req_size <= req_fifo_dout(REQ_FIFO_DATA_WIDTH-1-32-1 downto REQ_FIFO_DATA_WIDTH -1-32-32);
  req_fifo_dout_req_address <= req_fifo_dout(REQ_FIFO_DATA_WIDTH-1-1 downto REQ_FIFO_DATA_WIDTH -1-32);

  req_fifo_dout_req_size_normalize(31 downto USER_ADDR_SHIFT) <= req_fifo_dout_req_size(31-USER_ADDR_SHIFT downto 0);
  req_fifo_dout_req_size_normalize(USER_ADDR_SHIFT-1 downto 0) <= (others => '0');

  process(req_fifo_empty_n, req_valid)
  begin
    req_fifo_pop <= '0';
    if (req_fifo_empty_n = '1' and req_valid = '0') then -- lunch next request
        req_fifo_pop <= '1';
    end if;
  end process;

  process (MPLB_Clk, MPLB_Rst)
  variable offset: integer;
  begin
    if (MPLB_Rst = '1') then
        req_nRW <= '0';
        burst_size <= (others => '0');
        req_size_user <= (others => '0');
        req_address <= (others => '0'); 
        req_WrData <= (others => '0'); -- set possible MSB to ZERO
        req_WrData_BE <= (others => '0'); -- set possible MSB to ZERO
        req_WrData_byte_p <= (others => '0'); -- set possible MSB to ZERO
        req_valid <= '0';
        req_EOP <= '0';
        req_burst_write_counter <= (others => '0');
        req_burst_mode <= '0';
    elsif (MPLB_Clk'event and MPLB_Clk = '1') then
        if (req_fifo_pop = '1') then -- lunch next request
            req_valid <= '1';
            if (req_burst_mode = '0') then
                if (req_fifo_dout_req_nRW = '0') then
                    if (req_fifo_dout_req_size_normalize(PLB_ADDR_SHIFT-1 downto 0) = CONV_STD_LOGIC_VECTOR(0,PLB_ADDR_SHIFT) and 
                        req_fifo_dout_req_address(PLB_ADDR_SHIFT-1 downto 0) = CONV_STD_LOGIC_VECTOR(0,PLB_ADDR_SHIFT)) then
                            burst_size(31-PLB_ADDR_SHIFT downto 0) <= req_fifo_dout_req_size_normalize(31 downto PLB_ADDR_SHIFT);
                    elsif (('0'&req_fifo_dout_req_size_normalize(PLB_ADDR_SHIFT-1 downto 0)) + 
                        ('0'&req_fifo_dout_req_address(PLB_ADDR_SHIFT-1 downto 0)) <= PLB_BYTE_COUNT) then
                            burst_size(31-PLB_ADDR_SHIFT downto 0) <= req_fifo_dout_req_size_normalize(31 downto PLB_ADDR_SHIFT) + 1;
                    else
                            burst_size(31-PLB_ADDR_SHIFT downto 0) <= req_fifo_dout_req_size_normalize(31 downto PLB_ADDR_SHIFT) + 2;
                    end if;
                else
                    burst_size <= X"00000001";      -- single by default
                    if (req_fifo_dout_req_size_normalize(31 downto PLB_ADDR_SHIFT+1) /= CONV_STD_LOGIC_VECTOR(0,31-PLB_ADDR_SHIFT)) then -- may burst
                        burst_size(31 downto 32-PLB_ADDR_SHIFT) <= (others=>'0');     -- burst_size for write operation
                        if (req_fifo_dout_req_address(PLB_ADDR_SHIFT-1 downto 0) = CONV_STD_LOGIC_VECTOR(0, PLB_ADDR_SHIFT)) or
                           (conv_integer(req_fifo_dout_req_address(PLB_ADDR_SHIFT-1 downto 0)) + conv_integer(req_fifo_dout_req_size_normalize(PLB_ADDR_SHIFT-1 downto 0)) >= PLB_BYTE_COUNT) then
                            burst_size(31-PLB_ADDR_SHIFT downto 0) <= req_fifo_dout_req_size_normalize(31 downto PLB_ADDR_SHIFT);
                        else
                            burst_size(31-PLB_ADDR_SHIFT downto 0) <= req_fifo_dout_req_size_normalize(31 downto PLB_ADDR_SHIFT)-1;
                        end if;
                    end if;
                end if;

                offset := conv_integer(req_fifo_dout_req_address(PLB_ADDR_SHIFT-1 downto 0));
                if (req_fifo_dout_req_nRW = '1') then
                    req_WrData(USER_DATA_WIDTH_2N +offset*8 -1 downto offset*8) <= req_fifo_dout(USER_DATA_WIDTH_2N -1 downto 0);
                    req_WrData_BE(USER_DATA_BYTE_COUNT+offset-1 downto offset) <= (others => '1');
                end if;

                req_size_user <= req_fifo_dout_req_size;    -- for read operation
                req_nRW <= req_fifo_dout_req_nRW;
                req_EOP <= '1'; 
                req_address <= req_fifo_dout_req_address;
                req_burst_write_counter <= req_fifo_dout_req_size;
                req_WrData_byte_p <= req_fifo_dout_req_address(PLB_ADDR_SHIFT-1 downto 0) + USER_DATA_BYTE_COUNT;

                if (req_fifo_dout_req_nRW = '1' and req_fifo_dout_req_size(31 downto 1) /= "0000000000000000000000000000000") then
                    req_burst_mode <= '1';
                    req_EOP <= '0'; 
                end if;
            else -- in a burst write process
                req_burst_write_counter <= req_burst_write_counter -1;
                offset := conv_integer(req_WrData_byte_p);
                req_WrData(USER_DATA_WIDTH_2N +offset*8 -1 downto offset*8) <= req_fifo_dout(USER_DATA_WIDTH_2N -1 downto 0);
                req_WrData_BE(USER_DATA_BYTE_COUNT+offset-1 downto offset) <= (others => '1');
                req_WrData_byte_p <= req_WrData_byte_p + USER_DATA_BYTE_COUNT;

                if (req_last_burst = '1') then
                    req_burst_mode <= '0';
                    req_EOP <= '1'; 
                end if;
            end if;
        elsif (req_valid = '1') then
            if (req_nRW = '0' and PLB_master_if_req_push = '1') then
                req_valid <= '0';
            elsif (req_nRW = '1') then
                if (req_EOP = '1' and PLB_master_if_req_push = '1') then -- last burst request 
                    if (req_WrData_BE(ALIGN_DATA_BE_WIDTH-1 downto PLB_BYTE_COUNT) = CONV_STD_LOGIC_VECTOR(0, ALIGN_DATA_BE_WIDTH-PLB_BYTE_COUNT)) then
                        req_valid <= '0';
                        req_EOP <= '0';
                        req_WrData <= (others=>'0');
                        req_WrData_BE <= (others => '0');
                    else
                        req_WrData(USER_DATA_WIDTH_2N + PLB_BW -1 downto USER_DATA_WIDTH_2N) <= (others => '0');
                        req_WrData(USER_DATA_WIDTH_2N -1 downto 0) <= req_WrData(USER_DATA_WIDTH_2N +PLB_BW -1 downto PLB_BW);
                        req_WrData_BE(ALIGN_DATA_BE_WIDTH -1 downto ALIGN_DATA_BE_WIDTH-PLB_BYTE_COUNT) <= (others => '0');
                        req_WrData_BE(ALIGN_DATA_BE_WIDTH -PLB_BYTE_COUNT-1 downto 0) <= req_WrData_BE(ALIGN_DATA_BE_WIDTH -1 downto PLB_BYTE_COUNT);
                        req_address(31 downto PLB_ADDR_SHIFT) <= req_address(31 downto PLB_ADDR_SHIFT) +1;
                        req_address(PLB_ADDR_SHIFT-1 downto 0) <= (others=>'0');
                    end if;
                elsif (req_EOP = '0') then
                    if (req_WrData_BE(PLB_BYTE_COUNT-1) = '0') then
                        req_valid <= '0';
                    elsif (req_WrData_BE(PLB_BYTE_COUNT-1) = '1' and PLB_master_if_req_push = '1') then
                        req_WrData(USER_DATA_WIDTH_2N + PLB_BW -1 downto USER_DATA_WIDTH_2N) <= (others => '0');
                        req_WrData(USER_DATA_WIDTH_2N -1 downto 0) <= req_WrData(USER_DATA_WIDTH_2N +PLB_BW -1 downto PLB_BW);
                        req_WrData_BE(ALIGN_DATA_BE_WIDTH -1 downto ALIGN_DATA_BE_WIDTH-PLB_BYTE_COUNT) <= (others => '0');
                        req_WrData_BE(ALIGN_DATA_BE_WIDTH-PLB_BYTE_COUNT-1 downto 0) <= req_WrData_BE(ALIGN_DATA_BE_WIDTH -1 downto PLB_BYTE_COUNT);
                        req_address(31 downto PLB_ADDR_SHIFT) <= req_address(31 downto PLB_ADDR_SHIFT) +1;
                        req_address(PLB_ADDR_SHIFT-1 downto 0) <= (others=>'0');
                    end if;
                end if;
            end if;
        end if;
    end if;
  end process;

  req_last_burst <= '1' when (req_burst_mode = '1' and req_burst_write_counter(31 downto 0) = X"00000002") else '0';

  process(req_nRW, req_WrData_BE, burst_size)
  begin
    req_size <= (others => '0');
    if (req_nRW = '0') then
        req_size <= burst_size;
    elsif (req_WrData_BE(PLB_BYTE_COUNT-1 downto 0) = BE_ALL_ONE) then
        req_size <= burst_size;
    else
        req_size <= X"00000001";
    end if;
  end process;

  process(req_valid, PLB_master_if_req_full_n, req_nRW, req_WrData_BE)
  begin
    PLB_master_if_req_push <= '0';
    if (req_valid = '1' and PLB_master_if_req_full_n = '1') then
        if (req_nRW = '0') then
            PLB_master_if_req_push <= '1';  -- only push when the last byte been push
        elsif (req_WrData_BE(PLB_BYTE_COUNT-1) = '1' or (req_EOP = '1' and req_WrData_BE(PLB_BYTE_COUNT-1 downto 0) /= CONV_STD_LOGIC_VECTOR(0, PLB_BYTE_COUNT))) then
            PLB_master_if_req_push <= '1';  -- only push when the last byte been push
        end if;
    end if;
  end process;

req_BE <= req_WrData_BE(PLB_BYTE_COUNT-1 downto 0) when req_nRW = '1' else (others => '1');

U_nfa_finals_buckets_if_plb_master_if: component nfa_finals_buckets_if_plb_master_if 
  generic map(
    C_PLB_AWIDTH => C_PLB_AWIDTH,
    C_PLB_DWIDTH => C_PLB_DWIDTH,
    PLB_ADDR_SHIFT => PLB_ADDR_SHIFT)
  port map (
    -- Bus protocol ports, do not add to or delete
    PLB_Clk => MPLB_Clk,
    PLB_Rst => MPLB_Rst,

    M_abort => M_abort,
    M_ABus  => M_ABus,
    M_BE    => M_BE,
    M_busLock   => M_busLock,
    M_lockErr   => M_lockErr,
    M_MSize => M_MSize,
    M_priority  => M_priority,
    M_rdBurst   => M_rdBurst,
    M_request   => M_request,
    M_RNW   => M_RNW,
    M_size  => M_size,
    M_type  => M_type,
    M_wrBurst   => M_wrBurst,
    M_wrDBus    => M_wrDBus,

    PLB_MBusy   => PLB_MBusy,
    PLB_MWrBTerm    => PLB_MWrBTerm,
    PLB_MWrDAck => PLB_MWrDAck,
    PLB_MAddrAck    => PLB_MAddrAck,
    PLB_MRdBTerm    => PLB_MRdBTerm,
    PLB_MRdDAck => PLB_MRdDAck,
    PLB_MRdDBus => PLB_MRdDBus,
    PLB_MRdWdAddr   => PLB_MRdWdAddr,
    PLB_MRearbitrate    => PLB_MRearbitrate,
    PLB_MSSize  => PLB_MSSize,

    -- signals from user logic
    BUS_RdData => PLB_master_if_dataout,
    BUS_WrData => req_WrData(PLB_BW-1 downto 0),
    BUS_address    => req_address,
    BUS_size   => req_size,
    BUS_req_nRW    => req_nRW,
    BUS_req_BE    => req_BE,
    BUS_req_full_n => PLB_master_if_req_full_n,
    BUS_req_push   => PLB_master_if_req_push,
    BUS_rsp_nRW    => PLB_master_if_rsp_nRW,
    BUS_rsp_empty_n  => PLB_master_if_rsp_empty_n,
    BUS_rsp_pop    => PLB_master_if_rsp_pop 
  );

  -- below is the response (bus read data) part
  U_nfa_finals_buckets_if_rsp_fifo: component nfa_finals_buckets_if_ap_fifo 
  generic map(
    DATA_WIDTH => RSP_FIFO_DATA_WIDTH,
    ADDR_WIDTH => RSP_FIFO_ADDR_WIDTH,
    DEPTH => RSP_FIFO_DEPTH)
  port map(
    clk        => MPLB_Clk,
    reset      => MPLB_Rst,
    if_empty_n => rsp_fifo_empty_n,
    if_read    => rsp_fifo_pop,
    if_dout    => rsp_fifo_dout,
    if_full_n  => rsp_fifo_full_n,
    if_write   => rsp_fifo_push,
    if_din     => rsp_fifo_din
  );
  rsp_fifo_din(32+PLB_ADDR_SHIFT-1 downto 32) <= req_address(PLB_ADDR_SHIFT-1 downto 0);
  rsp_fifo_din(31 downto 0) <= req_size_user;
  rsp_fifo_push <= PLB_master_if_req_push and (not req_nRW);

  process (rsp_valid, PLB_master_if_rsp_empty_n, rsp_rd_data_byte_count)
  begin
    PLB_master_if_rsp_pop <= '0';
    -- fetch data to rsp_rd_data until enough bytes
    if (rsp_valid = '1' and PLB_master_if_rsp_empty_n = '1' and CONV_INTEGER(rsp_rd_data_byte_count) < USER_DATA_BYTE_COUNT) then
        PLB_master_if_rsp_pop <= '1';
    end if;
  end process;

  process (MPLB_Clk, MPLB_Rst)
  begin
    if (MPLB_Rst = '1') then
        rsp_valid <= '0';
        rsp_addr <= (others=> '0');
        rsp_size <= (others=> '0');
        rsp_SOP <= '1';

        rsp_rd_data_byte_count <= (others => '0');
        rsp_rd_data <= (others=>'0');

        rsp_fifo_pop <= '0';
    elsif (MPLB_Clk'event and MPLB_Clk = '1') then
        rsp_fifo_pop <= '0';
        if (rsp_valid = '0' and rsp_fifo_empty_n = '1') then
            rsp_valid <= '1';
            rsp_addr <= rsp_fifo_dout(32+PLB_ADDR_SHIFT-1 downto 32);
            rsp_size <= rsp_fifo_dout(31 downto 0);
            rsp_fifo_pop <= '1';
            rsp_rd_data_byte_count <= (others=>'0');
            rsp_SOP <= '1';
        end if;

        -- fetch data to rsp_rd_data until enough bytes
        if (PLB_master_if_rsp_pop = '1') then
            rsp_rd_data(USER_DATA_WIDTH_2N-1 downto 0) <= rsp_rd_data(USER_DATA_WIDTH_2N + PLB_BW -1 downto PLB_BW);
            rsp_rd_data(USER_DATA_WIDTH_2N +PLB_BW -1 downto USER_DATA_WIDTH_2N) <= PLB_master_if_dataout;
            if (rsp_SOP = '1') then
                rsp_rd_data_byte_count <= rsp_rd_data_byte_count + PLB_BYTE_COUNT - rsp_addr;
                rsp_SOP <= '0';
            else
                rsp_rd_data_byte_count <= rsp_rd_data_byte_count + PLB_BYTE_COUNT;
            end if;
        end if;

        -- write one unit of data to USER LOGIC
        if (rd_data_user_fifo_push = '1') then
            rsp_size <= rsp_size -1;
            rsp_rd_data_byte_count <= rsp_rd_data_byte_count - USER_DATA_BYTE_COUNT;
            rsp_addr <= rsp_addr + USER_DATA_BYTE_COUNT;
            if (rsp_size = X"00000001") then
                rsp_valid <= '0';
            end if;
        end if;
    end if;
  end process;

  process(rsp_addr, rsp_rd_data,rsp_valid, rd_data_user_fifo_full_n, rsp_rd_data_byte_count, rd_data_user_fifo_din_2N)
  variable i: integer;
  begin
    case CONV_INTEGER(rsp_addr) is
    when 0 => rd_data_user_fifo_din_2N <= rsp_rd_data(USER_DATA_WIDTH_2N +32 -1 downto 32);
    when 1 => rd_data_user_fifo_din_2N <= rsp_rd_data(USER_DATA_WIDTH_2N +40 -1 downto 40);
    when 2 => rd_data_user_fifo_din_2N <= rsp_rd_data(USER_DATA_WIDTH_2N +48 -1 downto 48);
    when 3 => rd_data_user_fifo_din_2N <= rsp_rd_data(USER_DATA_WIDTH_2N +56 -1 downto 56);
    when 4 => rd_data_user_fifo_din_2N <= rsp_rd_data(USER_DATA_WIDTH_2N +64 -1 downto 64);
    when 5 => rd_data_user_fifo_din_2N <= rsp_rd_data(USER_DATA_WIDTH_2N +8 -1 downto 8);
    when 6 => rd_data_user_fifo_din_2N <= rsp_rd_data(USER_DATA_WIDTH_2N +16 -1 downto 16);
    when 7 => rd_data_user_fifo_din_2N <= rsp_rd_data(USER_DATA_WIDTH_2N +24 -1 downto 24);
    when others => null;
    end case;

    for i in 0 to USER_DATA_WIDTH -1 loop
        rd_data_user_fifo_din(i) <= rd_data_user_fifo_din_2N(USER_DATA_WIDTH_2N-1-i);
    end loop;

    rd_data_user_fifo_push <= '0';
    if (rsp_valid = '1' and rd_data_user_fifo_full_n = '1' and 
        CONV_INTEGER(rsp_rd_data_byte_count)>= USER_DATA_BYTE_COUNT) then
        rd_data_user_fifo_push <= '1';
    end if;
  end process;

  U_nfa_finals_buckets_if_rd_data_user_fifo: component nfa_finals_buckets_if_ap_fifo 
  generic map(
    DATA_WIDTH => USER_DATA_WIDTH,
    ADDR_WIDTH => 5,
    DEPTH => 32)
  port map(
    clk        => MPLB_Clk,
    reset      => MPLB_Rst,
    if_empty_n => rd_data_user_fifo_empty_n,
    if_read    => USER_rsp_pop,
    if_dout    => rd_data_user_fifo_dout,
    if_full_n  => rd_data_user_fifo_full_n,
    if_write   => rd_data_user_fifo_push,
    if_din     => rd_data_user_fifo_din
  );
  USER_RdData <= rd_data_user_fifo_dout;
  USER_rsp_empty_n <= rd_data_user_fifo_empty_n;

end IMP;
